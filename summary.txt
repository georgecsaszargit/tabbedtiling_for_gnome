===== FILE: ./schemas/gschemas.compiled =====
[BINARY FILE]



===== FILE: ./schemas/org.gnome.shell.extensions.tabbedtiling.gschema.xml =====
<?xml version="1.0" encoding="UTF-8"?>
<schemalist gettext-domain="gnome-shell-extensions">
  <schema path="/org/gnome/shell/extensions/tabbedtiling/" id="org.gnome.shell.extensions.tabbedtiling">
    <key name="enable-auto-zoning" type="b">
      <default>true</default>
      <summary>Enable Auto Zoning</summary>
      <description>Automatically tile windows when moved into a defined zone.</description>
    </key>

    <key name="zones" type="s">
	  <default>'[]'</default>
	  <summary>Zone Definitions</summary>
	  <description>A JSON string representing an array of zone objects. Coordinates are relative to the full monitor geometry (including panels and docks).</description>
	</key>

    <key name="restore-original-size-on-untile" type="b">
      <default>true</default>
      <summary>Restore Original Size</summary>
      <description>When a window leaves all zones, restore its previous size/position.</description>
    </key>

    <key name="tile-new-windows" type="b">
      <default>true</default>
      <summary>Tile New Windows</summary>
      <description>Automatically tile newly opened windows if they fall into a zone.</description>
    </key>

    <key name="highlight-on-hover" type="b">
      <default>true</default>
      <summary>Highlight Zone on Hover</summary>
      <description>Visually highlight a zone when dragging a window over it.</description>
    </key>

    <key name="cycle-zone-windows-accelerator" type="as">
      <default>['&lt;Control&gt;&lt;Alt&gt;8']</default>
      <summary>Cycle Windows Forward</summary>
      <description>Keyboard shortcut to loop focus forward through windows in the active zone.</description>
    </key>

    <key name="cycle-zone-windows-backward-accelerator" type="as">
      <default>['&lt;Control&gt;&lt;Alt&gt;9']</default>
      <summary>Cycle Windows Backward</summary>
      <description>Keyboard shortcut to loop focus backward through windows in the active zone.</description>
    </key>

    <key name="tab-bar-height" type="i">
      <default>32</default>
      <summary>Tab Bar Height</summary>
      <description>Height in pixels of the tab bar.</description>
    </key>

    <key name="tab-font-size" type="i">
      <default>13</default>
      <summary>Tab Font Size</summary>
      <description>Font size in pixels for the tab labels.</description>
    </key>

    <key name="zone-gap-size" type="i">
      <default>5</default>
      <summary>Zone Gap Size</summary>
      <description>Pixel size of the gap around and between window zones. Set to 0 to disable gaps. Changes may require a re-snap of windows.</description>
    </key>

    <key name="tab-icon-size" type="i">
      <default>24</default>
      <summary>Tab Icon Size</summary>
      <description>Size in pixels for the application icon in tabs.</description>
    </key>

    <key name="tab-corner-radius" type="i">
      <default>4</default>
      <summary>Tab Corner Radius</summary>
      <description>Corner radius in pixels for individual tabs. Affects the top corners.</description>
    </key>

    <key name="tab-close-button-icon-size" type="i">
      <default>18</default>
      <summary>Tab Close Button Icon Size</summary>
      <description>Size in pixels for the close button icon within tabs.</description>
    </key>

    <key name="tab-spacing" type="i">
      <default>20</default>
      <summary>Tab Spacing</summary>
      <description>Gap in pixels between individual tabs in the tab bar.</description>
    </key>

    <key name="tab-min-width" type="i">
      <default>80</default>
      <summary>Tab Minimum Width</summary>
      <description>Minimum width in pixels for an individual tab.</description>
    </key>

    <key name="tab-max-width" type="i">
      <default>180</default>
      <summary>Tab Maximum Width</summary>
      <description>Maximum width in pixels for an individual tab.</description>
    </key>

    <key name="snap-evasion-key" type="s">
      <default>'control'</default>
      <summary>Snap Evasion Key</summary>
      <description>Hold this key while dragging a window to temporarily prevent snapping to zones.</description>
      <choices>
        <choice value='disabled'/>
        <choice value='control'/>
        <choice value='alt'/>
        <choice value='shift'/>
        <choice value='super'/>
      </choices>
    </key>

    <key name="app-name-exceptions" type="as">
      <default>['virt-manager.desktop']</default>
      <summary>App Name Exceptions</summary>
      <description>List of application IDs that should show window title instead of app name in tabs.</description>
    </key>

    <key name="window-title-word-count" type="i">
      <default>1</default>
      <summary>Window Title Word Count</summary>
      <description>Number of words from the window title to show in tabs for applications in the exceptions list. Set to 0 to show the full title.</description>
      <range min="0" max="10"/>
    </key>

  </schema>
</schemalist>



===== FILE: ./metadata.json =====
{
  "name": "TabbedTiling",
  "description": "Automatically tiles windows into predefined screen zones with tabbed interface.",
  "uuid": "tabbedtiling@georgecs.com",
  "shell-version": ["45", "46", "47", "48"],
  "version": 1,
  "gettext-domain": "tabbedtiling",
  "settings-schema": "org.gnome.shell.extensions.tabbedtiling",
  "url": "https://github.com/your-username/tabbedtiling"
}



===== FILE: ./extension.js =====
// extension.js

import { Extension } from 'resource:///org/gnome/shell/extensions/extension.js'; 
import * as Main from 'resource:///org/gnome/shell/ui/main.js'; 
import Meta from 'gi://Meta'; 
import Shell from 'gi://Shell'; 
import GLib from 'gi://GLib'; 
import Gio from 'gi://Gio'; 

import { SettingsManager } from './modules/SettingsManager.js'; 
import { HighlightManager } from './modules/HighlightManager.js'; 
import { WindowManager } from './modules/WindowManager.js'; 
import { Indicator } from './modules/Indicator.js'; 

const ENABLE_ZONING_KEY = 'enable-auto-zoning'; 
const CYCLE_ACCELERATOR_KEY = 'cycle-zone-windows-accelerator'; 
const CYCLE_BACKWARD_ACCELERATOR_KEY = 'cycle-zone-windows-backward-accelerator'; 
const ZONE_GAP_SIZE_KEY = 'zone-gap-size'; 
const TAB_BAR_HEIGHT_KEY = 'tab-bar-height'; 
// New Tab Bar Adjustment Keys (ensure these match gschema and SettingsManager) 
const TAB_ICON_SIZE_KEY = 'tab-icon-size'; 
const TAB_CORNER_RADIUS_KEY = 'tab-corner-radius'; 
const TAB_CLOSE_BUTTON_ICON_SIZE_KEY = 'tab-close-button-icon-size'; 
const TAB_SPACING_KEY = 'tab-spacing'; 
const TAB_MIN_WIDTH_KEY = 'tab-min-width'; 
const TAB_MAX_WIDTH_KEY = 'tab-max-width'; 
const TAB_FONT_SIZE_KEY = 'tab-font-size'; 
// Already existed but good to have with other tab keys

const log = msg => console.log(`[TabbedTiling.Main] ${msg}`);
const SessionManagerIface = `
<node>
    <interface name="org.gnome.SessionManager">
        <signal name="Resumed" />
    </interface>
</node>`; 
const SessionManagerProxy = Gio.DBusProxy.makeProxyWrapper(SessionManagerIface); 

export default class TabbedTilingExtension extends Extension {
    constructor(metadata) {
        super(metadata); 
        this._settingsManager = null; 
        this._highlightManager = null; 
        this._windowManager = null; 
        this._indicator = null; 
        this._monitorsChangedId = 0; 
        this._snapOnMonitorsChangedTimeoutId = 0; 
        this._zoningChangedId = 0; 
        this._cycleAccelChangedId = 0; 
        this._cycleBackwardAccelChangedId = 0; 
        this._zoneGapChangedId = 0; 
        this._tabBarHeightChangedId = 0; 
        this._tabFontSizeChangedId = 0; 
        // For completeness if dynamic changes are needed 

        // IDs for new tab settings signals
        this._tabIconSizeChangedId = 0; 
        this._tabCornerRadiusChangedId = 0; 
        this._tabCloseButtonIconSizeChangedId = 0; 
        this._tabSpacingChangedId = 0; 
        this._tabMinWidthChangedId = 0; 
        this._tabMaxWidthChangedId = 0; 

        this._sessionProxy = null; 
        this._sessionResumedSignalId = 0; 
        this._snapOnResumeTimeoutId = 0; 
    }

    _performDelayedSnap(reason = "unknown change") {
        if (this._settingsManager && this._settingsManager.isZoningEnabled() && this._windowManager) { 
            log(`Re-snapping windows due to: ${reason}`); 
            this._windowManager.snapAllWindowsToZones(); 
        }
    }

    _updateAllTabsAppearance(reason = "unknown tab setting change") {
        log(`Updating tab appearances due to: ${reason}`); 
        if (this._settingsManager && this._settingsManager.isZoningEnabled() && this._windowManager) { 
            this._windowManager.updateAllTabAppearances(); 
        }
    }

    enable() {
        log('Enabling…'); 
        this._settingsManager = new SettingsManager(this.getSettings(), this.path); 
        this._highlightManager = new HighlightManager(this._settingsManager); 
        this._windowManager = new WindowManager(this._settingsManager, this._highlightManager); 
        this._indicator = new Indicator(this.uuid, this._settingsManager, this); 
        this._windowManager.connectSignals();
        if (this._settingsManager.isZoningEnabled()) { 
            GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 300, () => { 
                if (this._settingsManager && this._settingsManager.isZoningEnabled() && this._windowManager) { 
                    log('Performing initial snapAllWindowsToZones after delay...'); 
                    this._performDelayedSnap("initial enable"); 
                }
                return GLib.SOURCE_REMOVE; 
            });
        }

        this._zoningChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${ENABLE_ZONING_KEY}`, 
            () => {
                this._windowManager.connectSignals(); 
                if (this._settingsManager.isZoningEnabled()) { 
                    // Perform a full refresh including potential splits
                    if (this._windowManager) this._windowManager.refreshZonesAndLayout(); 
                } else { 
                    if (this._windowManager) this._windowManager.cleanupWindowProperties(); // Clean up if disabled
                }
                this._indicator.updateToggleState(); 
            }
        );
        this._zoneGapChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${ZONE_GAP_SIZE_KEY}`, 
            () => {
                log('Zone gap size setting changed; re-snapping windows...'); 
                if (this._windowManager) this._windowManager._rebuildAndResnapAll(); // Full rebuild for gap changes 
            }
        );
        this._tabBarHeightChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_BAR_HEIGHT_KEY}`, 
            () => {
                log('Tab bar height setting changed; re-snapping windows and updating tabs...'); 
                // Snapping also updates tab bar position/size, a full rebuild is safer
                if (this._windowManager) this._windowManager._rebuildAndResnapAll(); 
                this._updateAllTabsAppearance("tab bar height change"); 
            }
        );
        this._tabFontSizeChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_FONT_SIZE_KEY}`, 
            () => {
                log('Tab font size setting changed; updating tabs...'); 
                this._updateAllTabsAppearance("tab font size change"); 
            }
        );
        // Connect signals for new tab settings 
        this._tabIconSizeChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_ICON_SIZE_KEY}`, () => this._updateAllTabsAppearance("tab icon size change") 
        );
        this._tabCornerRadiusChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_CORNER_RADIUS_KEY}`, () => this._updateAllTabsAppearance("tab corner radius change") 
        );
        this._tabCloseButtonIconSizeChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_CLOSE_BUTTON_ICON_SIZE_KEY}`, () => this._updateAllTabsAppearance("tab close button icon size change") 
        );
        this._tabSpacingChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_SPACING_KEY}`, () => this._updateAllTabsAppearance("tab spacing change") 
        );
        this._tabMinWidthChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_MIN_WIDTH_KEY}`, () => this._updateAllTabsAppearance("tab min width change") 
        );
        this._tabMaxWidthChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${TAB_MAX_WIDTH_KEY}`, () => this._updateAllTabsAppearance("tab max width change") 
        );
        if (Main.layoutManager) { 
            this._monitorsChangedId = Main.layoutManager.connect( 
                'monitors-changed', 
                () => {
                    log('Monitors changed event detected.'); 
                    if (this._highlightManager) this._highlightManager.reinitHighlighters(); 

                    if (this._snapOnMonitorsChangedTimeoutId > 0) { 
                        GLib.Source.remove(this._snapOnMonitorsChangedTimeoutId); 
                    }
                    this._snapOnMonitorsChangedTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 750, () => { 
                        log('Processing monitors changed event (delayed).'); 
                        if (this._windowManager) this._windowManager.refreshZonesAndLayout(); // Full refresh on monitor change 
                        this._snapOnMonitorsChangedTimeoutId = 0; 
                        return GLib.SOURCE_REMOVE; 
                    });
                }
            );
        }

        try { 
            this._sessionProxy = new SessionManagerProxy( 
                Gio.DBus.session, 
                'org.gnome.SessionManager', 
                '/org/gnome/SessionManager', 
                (proxy, error) => { 
                    if (error) { 
                        log(`Error creating SessionManager proxy: ${error.message}`); 
                        this._sessionProxy = null; 
                        return; 
                    }
                    if (!this._sessionProxy) { 
                        log('SessionManager proxy initialization failed silently.'); 
                        return; 
                    }
                    this._sessionResumedSignalId = this._sessionProxy.connectSignal('Resumed', () => { 
                        log('System Resumed signal received.'); 
                        if (this._snapOnResumeTimeoutId > 0) { 
                            GLib.Source.remove(this._snapOnResumeTimeoutId); 
                        }
                        this._snapOnResumeTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 1000, () => { 
                            log('Processing Resumed signal (delayed snap).'); 
                            if (this._windowManager) this._windowManager.refreshZonesAndLayout(); // Full refresh on resume 
                            this._snapOnResumeTimeoutId = 0; 
                            return GLib.SOURCE_REMOVE; 
                        });
                    });
                    log('Connected to SessionManager Resumed signal.'); 
                }
            );
        } catch (e) { 
            log(`Failed to create SessionManager D-Bus proxy: ${e}`); 
            this._sessionProxy = null; 
        }

        this._addCycleKeybinding(); 
        this._addCycleBackwardKeybinding(); 
        this._cycleAccelChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${CYCLE_ACCELERATOR_KEY}`, 
            () => {
                log('Cycle accelerator changed; rebinding…'); 
                Main.wm.removeKeybinding(CYCLE_ACCELERATOR_KEY); 
                this._addCycleKeybinding(); 
            }
        );
        this._cycleBackwardAccelChangedId = this._settingsManager.getGSettingObject().connect( 
            `changed::${CYCLE_BACKWARD_ACCELERATOR_KEY}`, 
            () => {
                log('Backward cycle accelerator changed; rebinding…'); 
                Main.wm.removeKeybinding(CYCLE_BACKWARD_ACCELERATOR_KEY); 
                this._addCycleBackwardKeybinding(); 
            }
        );

        log('Enabled.'); 
    }

    disable() {
        log('Disabling…'); 
        if (this._snapOnMonitorsChangedTimeoutId > 0) { 
            GLib.Source.remove(this._snapOnMonitorsChangedTimeoutId); 
            this._snapOnMonitorsChangedTimeoutId = 0; 
        }
        if (this._snapOnResumeTimeoutId > 0) { 
            GLib.Source.remove(this._snapOnResumeTimeoutId); 
            this._snapOnResumeTimeoutId = 0; 
        }

        if (this._sessionProxy && this._sessionResumedSignalId > 0) { 
            try { 
                this._sessionProxy.disconnectSignal(this._sessionResumedSignalId); 
            } catch (e) { 
                log(`Error disconnecting SessionManager Resumed signal: ${e}`); 
            }
            this._sessionResumedSignalId = 0; 
        }
        this._sessionProxy = null; 
        if (this._monitorsChangedId > 0 && Main.layoutManager) { 
            Main.layoutManager.disconnect(this._monitorsChangedId); 
            this._monitorsChangedId = 0; 
        }
        const gsettingsObj = this._settingsManager.getGSettingObject(); 
        if (this._zoningChangedId > 0) { 
            gsettingsObj.disconnect(this._zoningChangedId); 
            this._zoningChangedId = 0; 
        }
        if (this._cycleAccelChangedId > 0) { 
            gsettingsObj.disconnect(this._cycleAccelChangedId); 
            this._cycleAccelChangedId = 0; 
        }
        if (this._cycleBackwardAccelChangedId > 0) { 
            gsettingsObj.disconnect(this._cycleBackwardAccelChangedId); 
            this._cycleBackwardAccelChangedId = 0; 
        }
        if (this._zoneGapChangedId > 0) { 
            gsettingsObj.disconnect(this._zoneGapChangedId); 
            this._zoneGapChangedId = 0; 
        }
        if (this._tabBarHeightChangedId > 0) { 
            gsettingsObj.disconnect(this._tabBarHeightChangedId); 
            this._tabBarHeightChangedId = 0; 
        }
        if (this._tabFontSizeChangedId > 0) { 
            gsettingsObj.disconnect(this._tabFontSizeChangedId); 
            this._tabFontSizeChangedId = 0; 
        }

        // Disconnect new tab settings signals
        if (this._tabIconSizeChangedId > 0) { 
            gsettingsObj.disconnect(this._tabIconSizeChangedId); 
            this._tabIconSizeChangedId = 0; 
        }
        if (this._tabCornerRadiusChangedId > 0) { 
            gsettingsObj.disconnect(this._tabCornerRadiusChangedId); 
            this._tabCornerRadiusChangedId = 0; 
        }
        if (this._tabCloseButtonIconSizeChangedId > 0) { 
            gsettingsObj.disconnect(this._tabCloseButtonIconSizeChangedId); 
            this._tabCloseButtonIconSizeChangedId = 0; 
        }
        if (this._tabSpacingChangedId > 0) { 
            gsettingsObj.disconnect(this._tabSpacingChangedId); 
            this._tabSpacingChangedId = 0; 
        }
        if (this._tabMinWidthChangedId > 0) { 
            gsettingsObj.disconnect(this._tabMinWidthChangedId); 
            this._tabMinWidthChangedId = 0; 
        }
        if (this._tabMaxWidthChangedId > 0) { 
            gsettingsObj.disconnect(this._tabMaxWidthChangedId); 
            this._tabMaxWidthChangedId = 0; 
        }

        Main.wm.removeKeybinding(CYCLE_ACCELERATOR_KEY); 
        Main.wm.removeKeybinding(CYCLE_BACKWARD_ACCELERATOR_KEY); 
        if (this._windowManager) { 
            this._windowManager.cleanupWindowProperties(); 
            this._windowManager.destroy(); 
            this._windowManager = null; 
        }
        if (this._highlightManager) { 
            this._highlightManager.destroy(); 
            this._highlightManager = null; 
        }
        if (this._indicator) { 
            this._indicator.destroy(); 
            this._indicator = null; 
        }
        if (this._settingsManager) { 
            this._settingsManager.destroy(); 
            this._settingsManager = null; 
        }

        log('Disabled.'); 
    }

    _addCycleKeybinding() {
        const accel = this._settingsManager.getGSettingObject().get_strv(CYCLE_ACCELERATOR_KEY)[0]; 
        log(`Binding cycle shortcut: ${accel}`); 

        Main.wm.addKeybinding( 
            CYCLE_ACCELERATOR_KEY, 
            this._settingsManager.getGSettingObject(), 
            Meta.KeyBindingFlags.NONE, 
            Shell.ActionMode.ALL, 
            () => {
                log('🏷️ Cycle shortcut pressed!'); 
                if (this._windowManager) this._windowManager.cycleWindowsInCurrentZone(); 
            }
        );
    }

    _addCycleBackwardKeybinding() {
        const accel = this._settingsManager.getGSettingObject().get_strv(CYCLE_BACKWARD_ACCELERATOR_KEY)[0]; 
        log(`Binding backward cycle shortcut: ${accel}`); 

        Main.wm.addKeybinding( 
            CYCLE_BACKWARD_ACCELERATOR_KEY, 
            this._settingsManager.getGSettingObject(), 
            Meta.KeyBindingFlags.NONE, 
            Shell.ActionMode.ALL, 
            () => {
                log('🏷️ Backward cycle shortcut pressed!'); 
                if (this._windowManager) this._windowManager.cycleWindowsInCurrentZoneBackward(); 
            }
        );
    }
}



===== FILE: ./preferences/ZoneEditorGrid.js =====
// ./preferences/ZoneEditorGrid.js
import Gtk from 'gi://Gtk'; 
import GObject from 'gi://GObject'; 
import { gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 

export const ZoneEditorGrid = GObject.registerClass({
    Signals: { 'changed': {} }
}, class ZoneEditorGrid extends Gtk.Grid {
    _init(zoneData, monitorCount) {
        super._init({
            column_spacing: 12, 
            row_spacing: 6, 
            margin_top: 10, 
            margin_bottom: 10, 
            margin_start: 10, 
            margin_end: 10, 
            hexpand: true, 
        });
        
        this._zone = { ...zoneData }; 
        
        this.attach(new Gtk.Label({ label: _('Name:'), halign: Gtk.Align.END }), 0, 0, 1, 1); 
        this._nameEntry = new Gtk.Entry({ text: this._zone.name || '', hexpand: true }); 
        this._nameEntry.connect('changed', () => { 
            this._zone.name = this._nameEntry.get_text(); 
            this.emit('changed'); 
        });
        this.attach(this._nameEntry, 1, 0, 3, 1); 

        this.attach(new Gtk.Label({ label: _('Monitor Index:'), halign: Gtk.Align.END }), 0, 1, 1, 1); 
        this._monitorSpin = Gtk.SpinButton.new_with_range(0, Math.max(0, monitorCount - 1), 1); 
        this._monitorSpin.set_value(this._zone.monitorIndex || 0); 
        this._monitorSpin.connect('value-changed', () => { 
            this._zone.monitorIndex = this._monitorSpin.get_value_as_int(); 
            this.emit('changed'); 
        });
        this.attach(this._monitorSpin, 1, 1, 1, 1); 

        const fields = [ 
            { label: _('X:'), key: 'x' }, { label: _('Y:'), key: 'y' }, 
            { label: _('Width:'), key: 'width' }, { label: _('Height:'), key: 'height' } 
        ];
        fields.forEach((f, i) => { 
            const row = Math.floor(i / 2) + 2; 
            const col = (i % 2) * 2; 
            this.attach(new Gtk.Label({ label: f.label, halign: Gtk.Align.END }), col, row, 1, 1); 
            const spin = Gtk.SpinButton.new_with_range(0, 10000, 10); 
            spin.set_value(this._zone[f.key] || 0); 
            spin.set_hexpand(true); 
            spin.connect('value-changed', () => { 
                this._zone[f.key] = spin.get_value_as_int(); 
                this.emit('changed'); 
            });
            this.attach(spin, col + 1, row, 1, 1); 
        });
    }

    get_zone_data() {
        return { ...this._zone }; 
    }
});



===== FILE: ./preferences/GeneralSettingsGroup.js =====
// ./preferences/GeneralSettingsGroup.js
import Adw from 'gi://Adw'; 
import Gtk from 'gi://Gtk'; 
import Gio from 'gi://Gio'; 
import { gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 

const ENABLE_ZONING_KEY                     = 'enable-auto-zoning'; 
const RESTORE_ON_UNTILE_KEY                 = 'restore-original-size-on-untile'; 
const TILE_NEW_WINDOWS_KEY                  = 'tile-new-windows'; 
const HIGHLIGHT_ON_HOVER_KEY                = 'highlight-on-hover'; 
const CYCLE_ACCELERATOR_KEY                 = 'cycle-zone-windows-accelerator'; 
const CYCLE_BACKWARD_ACCELERATOR_KEY        = 'cycle-zone-windows-backward-accelerator'; 
const ZONE_GAP_SIZE_KEY                     = 'zone-gap-size'; 
const SNAP_EVASION_KEY                      = 'snap-evasion-key'; 
const log = msg => console.log(`[TabbedTilingPrefs.GeneralSettings] ${msg}`); 

export function createGeneralSettingsGroup(settings) {
    const group = new Adw.PreferencesGroup({ title: _('General Settings') }); 

    // Enable Auto Zoning
    const enableSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER }); 
    settings.bind(ENABLE_ZONING_KEY, enableSwitch, 'active', Gio.SettingsBindFlags.DEFAULT); 
    const enableRow = new Adw.ActionRow({ 
        title: _('Enable Auto Zoning'), 
        subtitle: _('Globally enable or disable the extension'), 
        activatable_widget: enableSwitch 
    });
    enableRow.add_suffix(enableSwitch); 
    group.add(enableRow); 

    // Snap Evasion Key
    const evasionKeyChoices = [ 
        { value: 'disabled', label: _('Disabled') }, 
        { value: 'control',  label: _('Control') }, 
        { value: 'alt',      label: _('Alt') }, 
        { value: 'shift',    label: _('Shift') }, 
        { value: 'super',    label: _('Super (Windows/Cmd)') } 
    ];
    const evasionKeyModel = new Gtk.StringList(); 
    evasionKeyChoices.forEach(choice => evasionKeyModel.append(choice.label)); 

    const evasionKeyRow = new Adw.ComboRow({ 
        title: _('Snap Evasion Key'), 
        subtitle: _('Hold this key while dragging to prevent snapping'), 
        model: evasionKeyModel, 
    });
    const currentEvasionKey = settings.get_string(SNAP_EVASION_KEY); 
    let currentEvasionKeyIndex = evasionKeyChoices.findIndex(c => c.value === currentEvasionKey); 
    if (currentEvasionKeyIndex === -1) currentEvasionKeyIndex = 0; 
    evasionKeyRow.selected = currentEvasionKeyIndex; 
    evasionKeyRow.connect('notify::selected', () => { 
        const selectedIndex = evasionKeyRow.selected; 
        if (selectedIndex >= 0 && selectedIndex < evasionKeyChoices.length) { 
            settings.set_string(SNAP_EVASION_KEY, evasionKeyChoices[selectedIndex].value); 
        }
    });
    const evasionKeySettingChangedId = settings.connect(`changed::${SNAP_EVASION_KEY}`, () => { 
        const updatedKey = settings.get_string(SNAP_EVASION_KEY); 
        let updatedIndex = evasionKeyChoices.findIndex(c => c.value === updatedKey); 
        if (updatedIndex === -1) updatedIndex = 0; 
        if (evasionKeyRow.selected !== updatedIndex) { 
            evasionKeyRow.selected = updatedIndex; 
        }
    });
    // Disconnect signal handled by parent TabbedTilingPrefs window closure [cite: 567, 568, 610]
    group.add(evasionKeyRow); 

    // Highlight on Hover
    const hoverSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER }); 
    settings.bind(HIGHLIGHT_ON_HOVER_KEY, hoverSwitch, 'active', Gio.SettingsBindFlags.DEFAULT); 
    const hoverRow = new Adw.ActionRow({ 
        title: _('Highlight Zone on Hover'), 
        subtitle: _('Visually highlight a zone when dragging a window over it'), 
        activatable_widget: hoverSwitch 
    });
    hoverRow.add_suffix(hoverSwitch); 
    group.add(hoverRow); 

    // Restore Original Size on Untile
    const restoreSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER }); 
    settings.bind(RESTORE_ON_UNTILE_KEY, restoreSwitch, 'active', Gio.SettingsBindFlags.DEFAULT); 
    const restoreRow = new Adw.ActionRow({ 
        title: _('Restore Original Size on Untile'), 
        subtitle: _('When a window leaves all zones, restore its original size/position'), 
        activatable_widget: restoreSwitch 
    });
    restoreRow.add_suffix(restoreSwitch); 
    group.add(restoreRow); 

    // Tile New Windows
    const tileSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER }); 
    settings.bind(TILE_NEW_WINDOWS_KEY, tileSwitch, 'active', Gio.SettingsBindFlags.DEFAULT); 
    const tileRow = new Adw.ActionRow({ 
        title: _('Tile New Windows'), 
        subtitle: _('Automatically tile newly opened windows if they fall into a zone'), 
        activatable_widget: tileSwitch 
    });
    tileRow.add_suffix(tileSwitch); 
    group.add(tileRow); 

    // Cycle Zone Windows Shortcut (forward)
    const accelEntry = new Gtk.Entry({ 
        hexpand: true, 
        placeholder_text: '<Control><Alt>8' 
    });
    const existing = settings.get_strv(CYCLE_ACCELERATOR_KEY); 
    accelEntry.set_text(existing[0] || ''); 
    accelEntry.connect('changed', () => { 
        const text = accelEntry.get_text().trim(); 
        if (text) { 
            settings.set_strv(CYCLE_ACCELERATOR_KEY, [ text ]); 
            log(`Set cycle shortcut: ${text}`); 
        } else {
            settings.set_strv(CYCLE_ACCELERATOR_KEY, []); 
        }
    });
    const accelRow = new Adw.ActionRow({ 
        title: _('Cycle Zone Windows Shortcut'), 
        subtitle: _('E.g. <Control><Alt>8 or <Super>grave'), 
    });
    accelRow.add_suffix(accelEntry); 
    accelRow.activatable_widget = accelEntry; 
    group.add(accelRow); 

    // Cycle Zone Windows Backward Shortcut
    const backwardAccelEntry = new Gtk.Entry({ 
        hexpand: true, 
        placeholder_text: '<Control><Alt>9' 
    });
    const existingBackward = settings.get_strv(CYCLE_BACKWARD_ACCELERATOR_KEY); 
    backwardAccelEntry.set_text(existingBackward[0] || ''); 
    backwardAccelEntry.connect('changed', () => { 
        const text = backwardAccelEntry.get_text().trim(); 
        if (text) { 
            settings.set_strv(CYCLE_BACKWARD_ACCELERATOR_KEY, [ text ]); 
            log(`Set backward cycle shortcut: ${text}`); 
        } else {
            settings.set_strv(CYCLE_BACKWARD_ACCELERATOR_KEY, []); 
        }
    });
    const backwardAccelRow = new Adw.ActionRow({ 
        title: _('Cycle Zone Windows Backward Shortcut'), 
        subtitle: _('E.g. <Control><Shift><Alt>9 or <Super><Shift>grave'), 
    });
    backwardAccelRow.add_suffix(backwardAccelEntry); 
    backwardAccelRow.activatable_widget = backwardAccelEntry; 
    group.add(backwardAccelRow); 
    
    // Zone Gap Size
    const gapSpin = Gtk.SpinButton.new_with_range(0, 50, 1); 
    settings.bind(ZONE_GAP_SIZE_KEY, gapSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const gapRow = new Adw.ActionRow({ 
        title: _('Zone Gap Size (px)'), 
        subtitle: _('Gap around zones. 0 for no gaps. Re-snap windows to apply.'), 
        activatable_widget: gapSpin 
    });
    gapRow.add_suffix(gapSpin); 
    group.add(gapRow); 

    return { group, evasionKeySettingChangedId };
}



===== FILE: ./preferences/TabNamingSettingsGroup.js =====
// ./preferences/TabNamingSettingsGroup.js
import Adw from 'gi://Adw'; 
import Gtk from 'gi://Gtk'; 
import Gio from 'gi://Gio'; 
import { gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 

const APP_NAME_EXCEPTIONS_KEY = 'app-name-exceptions';
const WINDOW_TITLE_WORD_COUNT_KEY = 'window-title-word-count';
const log = msg => console.log(`[TabbedTilingPrefs.TabNaming] ${msg}`); 

export function createTabNamingSettingsGroup(settings) {
    const group = new Adw.PreferencesGroup({ 
        title: _('Tab Naming Behavior'),
        description: _('Configure how tab labels are displayed for different applications')
    }); 

    // Information section
    const infoRow = new Adw.ActionRow({
        title: _('How Tab Naming Works'),
        subtitle: _('Click to learn about tab naming behavior and configuration')
    });

    const infoButton = new Gtk.Button({
        icon_name: 'help-browser-symbolic',
        valign: Gtk.Align.CENTER,
        tooltip_text: _('Show tab naming help'),
        css_classes: ['flat', 'circular']
    });

    infoButton.connect('clicked', () => {
        _showTabNamingHelpDialog(infoRow.get_root());
    });

    infoRow.add_suffix(infoButton);
    group.add(infoRow);

    // Window Title Word Count
    const wordCountSpin = Gtk.SpinButton.new_with_range(0, 10, 1); 
    settings.bind(WINDOW_TITLE_WORD_COUNT_KEY, wordCountSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const wordCountRow = new Adw.ActionRow({ 
        title: _('Window Title Word Count'), 
        subtitle: _('Number of words to show from window title (0 = show full title)'), 
        activatable_widget: wordCountSpin 
    });
    wordCountRow.add_suffix(wordCountSpin); 
    group.add(wordCountRow); 

    // Add input row for new exceptions
    const addExceptionRow = new Adw.ActionRow({
        title: _('Add New Exception'),
        subtitle: _('Enter application ID (e.g., org.gnome.TextEditor)')
    });

    const exceptionEntry = new Gtk.Entry({
        placeholder_text: _('Application ID'),
        hexpand: true
    });

    const addButton = new Gtk.Button({
        label: _('Add'),
        valign: Gtk.Align.CENTER,
        css_classes: ['suggested-action']
    });

    addButton.connect('clicked', () => {
        const appId = exceptionEntry.get_text().trim();
        if (appId && _addAppIdToExceptions(settings, appId)) {
            exceptionEntry.set_text('');
            _refreshExceptionsList(settings, group, addExceptionRow);
        }
    });

    // Allow Enter key to add exception
    exceptionEntry.connect('activate', () => {
        addButton.emit('clicked');
    });

    addExceptionRow.add_suffix(exceptionEntry);
    addExceptionRow.add_suffix(addButton);
    group.add(addExceptionRow);

    // Load existing exceptions
    _refreshExceptionsList(settings, group, addExceptionRow);

    return group;
}

function _showTabNamingHelpDialog(parentWindow) {
    const helpText = `Tab Naming Behavior Explained:

DEFAULT BEHAVIOR:
• Most applications show their app name in tabs
• Example: "Firefox" for all Firefox windows
• Example: "Files" for all file manager windows

EXCEPTION BEHAVIOR:
• Applications in the exceptions list show window titles instead
• Useful for apps where the window title is more descriptive
• Example: Text editors showing document names
• Example: Terminals showing current directory

WORD COUNT SETTING:
• Controls how many words from window title to show
• 0 = Show full window title
• 1 = Show first word only (e.g., "document.txt" → "document.txt")
• 2 = Show first two words (e.g., "My Document - TextEditor" → "My Document")
• 3+ = Show specified number of words

EXAMPLES:

Normal App (Firefox):
• Tab shows: "Firefox" (always the same)

Exception App (Text Editor):
• Window title: "document.txt - Text Editor"
• Word count 1: Tab shows "document.txt"
• Word count 2: Tab shows "document.txt -"
• Word count 0: Tab shows "document.txt - Text Editor"

Exception App (Terminal):
• Window title: "user@hostname: /home/user/projects"
• Word count 1: Tab shows "user@hostname:"
• Word count 3: Tab shows "user@hostname: /home/user/projects"

APPLICATION IDs:
• Use the .desktop file name (e.g., "firefox.desktop")
• Or use the application ID (e.g., "org.gnome.TextEditor")
• Find app IDs using: "ps aux | grep [app-name]" or looking in /usr/share/applications/`;

    const dialog = new Adw.MessageDialog({
        heading: _("Tab Naming Configuration Guide"),
        body: helpText,
        transient_for: parentWindow,
        modal: true
    });
    dialog.add_response("ok", _("Got it"));
    dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED);
    dialog.connect("response", (d) => d.destroy());
    dialog.present();
}

function _isAppIdInExceptions(settings, appId) {
    const exceptions = settings.get_strv(APP_NAME_EXCEPTIONS_KEY);
    return exceptions.includes(appId); // Keep original case for exact match
}

function _addAppIdToExceptions(settings, appId) {
    const exceptions = settings.get_strv(APP_NAME_EXCEPTIONS_KEY);
    if (!exceptions.includes(appId)) { // Prevent duplicates
        exceptions.push(appId);
        settings.set_strv(APP_NAME_EXCEPTIONS_KEY, exceptions);
        log(`Added app ID to exceptions: ${appId}`);
        return true;
    }
    return false;
}

function _removeAppIdFromExceptions(settings, appId) {
    const exceptions = settings.get_strv(APP_NAME_EXCEPTIONS_KEY);
    const filtered = exceptions.filter(id => id !== appId);
    settings.set_strv(APP_NAME_EXCEPTIONS_KEY, filtered);
    log(`Removed app ID from exceptions: ${appId}`);
}

function _refreshExceptionsList(settings, group, addExceptionRow) {
    // Use a small delay to ensure GSettings changes are propagated
    setTimeout(() => {
        _doRefreshExceptionsList(settings, group, addExceptionRow);
    }, 100);
}

function _doRefreshExceptionsList(settings, group, addExceptionRow) {
    // Remove all exception rows except the fixed rows (info, word count, add row)
    let child = group.get_first_child();
    while (child) {
        const next = child.get_next_sibling();
        if (child instanceof Adw.ActionRow) {
            const title = child.title || '';
            
            const isFixedRow = title === _('How Tab Naming Works') ||
                   title === _('Window Title Word Count') ||
                   title === _('Add New Exception');

			if (isFixedRow) {
				// Keep these fixed rows
			} else {
				// This is an exception row (assuming its title is just the app ID), remove it
				group.remove(child);
			}
        }
        child = next;
    }

    // Get fresh data from GSettings
    const exceptions = settings.get_strv(APP_NAME_EXCEPTIONS_KEY);
    log(`Refreshing with ${exceptions.length} exceptions: ${exceptions.join(', ')}`);
    
    exceptions.forEach(appId => {
        const exceptionRow = new Adw.ActionRow({
            title: appId,
            subtitle: _('Shows window title instead of app name')
        });

        // Create a more visible delete button
        const removeButton = new Gtk.Button({
            label: _('Remove'),
            valign: Gtk.Align.CENTER,
            tooltip_text: _('Remove this exception'),
            css_classes: ['destructive-action']
        });

        removeButton.connect('clicked', () => {
            log(`User clicked remove for: ${appId}`);
            _removeAppIdFromExceptions(settings, appId);
            _refreshExceptionsList(settings, group, addExceptionRow);
        });

        exceptionRow.add_suffix(removeButton);
        exceptionRow.set_activatable_widget(null);
        
        // Add the row to the group
        group.add(exceptionRow);
        
        log(`Added exception row for: ${appId}`);
    });
}



===== FILE: ./preferences/ZoneDefinitionsGroup.js =====
// ./preferences/ZoneDefinitionsGroup.js
import Adw from 'gi://Adw'; 
import Gtk from 'gi://Gtk'; 
import { gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 
import { ZoneEditorGrid } from './ZoneEditorGrid.js'; // Assuming ZoneEditorGrid.js is in the same directory

const ZONE_SETTINGS_KEY = 'zones'; 
const log = msg => console.log(`[TabbedTilingPrefs.ZoneDefs] ${msg}`); 

export class ZoneDefinitionsGroup {
    constructor(settings, monitorCount, window) {
        this._settings = settings;
        this._monitorCount = monitorCount;
        this._window = window; // Reference to the main preferences window for dialogs

        this.group = new Adw.PreferencesGroup({ 
            title: _('Zone Definitions'), 
			description: _('Define screen areas where windows will tile automatically. Use full monitor coordinates (including panels and docks).')
        });

        // Add usage instructions
        this._addUsageInstructions();

        this._addButtonRow = new Adw.ActionRow(); 
        const addButton = new Gtk.Button({ 
            label: _('Add New Zone'), 
            halign: Gtk.Align.CENTER, 
            css_classes: ['suggested-action'] 
        });
        addButton.connect('clicked', () => this._addZone()); 
        this._addButtonRow.set_child(addButton); 

        this._loadZonesToUI();
    }

    _addUsageInstructions() {
		const instructionsRow = new Adw.ActionRow({
		    title: _('Zone Definition Tips'),
		    subtitle: _('Click to view detailed instructions for defining zones')
		});

		const helpButton = new Gtk.Button({
		    icon_name: 'help-browser-symbolic',
		    valign: Gtk.Align.CENTER,
		    tooltip_text: _('Show zone definition help'),
		    css_classes: ['flat', 'circular']
		});

		helpButton.connect('clicked', () => {
		    const helpText = "Zone coordinates are relative to the full monitor geometry.\n\n" +
							"Key Points:\n" +
							"• X, Y: Position from top-left of monitor (0,0)\n" +
							"• You must account for panels/docks in your coordinates\n" +
							"• Example: If you have a 32px thick top panel, start zones at Y=33\n" +
							"• Example: If you have a 60px wide dock on the left, start zones at X=61\n";
		    
		    const dialog = new Adw.MessageDialog({
		        heading: _("Zone Definition Guide"),
		        body: helpText,
		        transient_for: this._window.get_root(),
		        modal: true
		    });
		    dialog.add_response("ok", _("Got it"));
		    dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED);
		    dialog.connect("response", (d) => d.destroy());
		    dialog.present();
		});

		instructionsRow.add_suffix(helpButton);
		this.group.add(instructionsRow);
	}

    getWidget() {
        return this.group;
    }

    _loadZonesToUI() {
        // Clear previous expanders except the add button row
        let child = this.group.get_first_child(); 
        while (child) { 
            const next = child.get_next_sibling(); 
            if (child !== this._addButtonRow && child instanceof Adw.ExpanderRow) { 
                 this.group.remove(child); 
            }
            child = next; 
        }
        // Ensure add button row is removed if it exists, to re-add it at the end
        if (this._addButtonRow.get_parent() === this.group) { 
            this.group.remove(this._addButtonRow); 
        }

        let zones = []; 
        try {
            zones = JSON.parse(this._settings.get_string(ZONE_SETTINGS_KEY)); 
            if (!Array.isArray(zones)) zones = []; 
        } catch (e) {
            log(`Error parsing zones JSON: ${e}`); 
            zones = []; 
        }

        zones.forEach(zoneData => this._createAndAddZoneExpander(zoneData)); 
        
        this.group.add(this._addButtonRow); // Re-add the add button row
    }

    _createAndAddZoneExpander(zoneData) {
        const editorGrid = new ZoneEditorGrid(zoneData, this._monitorCount);
        const expanderRow = new Adw.ExpanderRow({
            title: zoneData.name || _('Unnamed Zone'),
            subtitle: `X:${zoneData.x}, Y:${zoneData.y}, W:${zoneData.width}, H:${zoneData.height}, M:${zoneData.monitorIndex + 1}`
        });
        expanderRow.add_row(editorGrid);

        const removeButton = new Gtk.Button({
            icon_name: 'edit-delete-symbolic',
            valign: Gtk.Align.CENTER,
            tooltip_text: _("Remove this zone"),
            css_classes: ['flat', 'circular']
        });
        expanderRow.add_suffix(removeButton);
        expanderRow.set_enable_expansion(true);

        editorGrid.connect('changed', () => {
            const cd = editorGrid.get_zone_data();
            expanderRow.title    = cd.name || _('Unnamed Zone');
            expanderRow.subtitle = `X:${cd.x}, Y:${cd.y}, W:${cd.width}, H:${cd.height}, M:${cd.monitorIndex + 1}`;
            this._saveZones();
        });
        removeButton.connect('clicked', () => {
            const dialog = new Adw.MessageDialog({
                heading: _("Remove Zone?"),
                body: _("Are you sure you want to remove this zone?"),
                transient_for: this._window.get_root(),
                modal: true
            });
            dialog.add_response("cancel", _("Cancel"));
            dialog.add_response("remove", _("Remove"));
            dialog.set_response_appearance("remove", Adw.ResponseAppearance.DESTRUCTIVE);
            dialog.connect("response", (d, resp) => {
                if (resp === "remove") {
                    this.group.remove(expanderRow);
                    this._saveZones();
                }
                d.destroy();
            });
            dialog.present();
        });
        
        // Add the new expander row. Ordering is handled by _loadZonesToUI
        // (which removes _addButtonRow and adds it back after all zones).
        this.group.add(expanderRow);
    }

    _addZone() {
        let current = []; 
        try {
            current = JSON.parse(this._settings.get_string(ZONE_SETTINGS_KEY)) || []; 
        } catch (e) {
            // Handle parsing error
        }
        const idx = current.length + 1; 
        const newZone = { 
            monitorIndex: 0, // Default to first monitor
            name:         _('New Zone %d').format(idx), 
            x: 0, y: 0, width: 600, height: 400 // Some default size
        };
        this._createAndAddZoneExpander(newZone); 
        this._saveZones(); 
    }

    _saveZones() {
        const zones = []; 
        let child = this.group.get_first_child(); 
        while (child) { 
            if (child instanceof Adw.ExpanderRow && child.get_n_rows() > 0) { 
                const firstRowContent = child.get_row_at_index(0); 
                if (firstRowContent instanceof ZoneEditorGrid) { 
                    zones.push(firstRowContent.get_zone_data()); 
                } else {
                    log('Warning: Could not find ZoneEditorGrid in ExpanderRow to save zone data.'); 
                }
            }
            child = child.get_next_sibling(); 
        }
        this._settings.set_string(ZONE_SETTINGS_KEY, JSON.stringify(zones)); 
        log(`Saved ${zones.length} zones.`); 
    }
}



===== FILE: ./preferences/AdvancedSettingsGroup.js =====
// ./preferences/AdvancedSettingsGroup.js
import Adw from 'gi://Adw'; 
import Gtk from 'gi://Gtk'; 
import Gio from 'gi://Gio'; 
import GLib from 'gi://GLib';
import { gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 

const log = msg => console.log(`[TabbedTilingPrefs.AdvancedSettings] ${msg}`); 

export function createAdvancedSettingsGroup(settings, extensionPath) {
    const group = new Adw.PreferencesGroup({ 
        title: _('Advanced Settings'),
        description: _('Advanced configuration options and information')
    }); 

    // Extension Information
    const infoRow = new Adw.ActionRow({
        title: _('Extension Information'),
        subtitle: _('View extension details and help information')
    });

    const infoButton = new Gtk.Button({
        icon_name: 'help-about-symbolic',
        valign: Gtk.Align.CENTER,
        tooltip_text: _('Show extension information'),
        css_classes: ['flat', 'circular']
    });

    infoButton.connect('clicked', () => {
        _showInfoDialog(infoRow.get_root());
    });

    infoRow.add_suffix(infoButton);
    group.add(infoRow);

    // Debug Information
    const debugRow = new Adw.ActionRow({
        title: _('Debug Information'),
        subtitle: _('View system and extension debug information')
    });

    const debugButton = new Gtk.Button({
        icon_name: 'applications-debugging-symbolic',
        valign: Gtk.Align.CENTER,
        tooltip_text: _('Show debug information'),
        css_classes: ['flat', 'circular']
    });

    debugButton.connect('clicked', () => {
        _showDebugDialog(debugRow.get_root());
    });

    debugRow.add_suffix(debugButton);
    group.add(debugRow);

    return group;
}

function _showInfoDialog(parentWindow) {
    const dialog = new Adw.MessageDialog({
        heading: _("TabbedTiling Extension"),
        body: _(`Version: 1.0
Author: TabbedTiling Team

Features:
• Automatic window tiling into predefined zones
• Tabbed interface for managing multiple windows per zone
• Customizable tab appearance and behavior
• Zone splitting functionality
• Keyboard shortcuts for window cycling
• Full monitor coordinate system for precise zone placement

For support and documentation, visit the extension homepage.`),
        transient_for: parentWindow,
        modal: true
    });
    dialog.add_response("ok", _("OK"));
    dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED);
    dialog.connect("response", (d) => d.destroy());
    dialog.present();
}

function _showDebugDialog(parentWindow) {
    const display = parentWindow.get_display();
    const monitors = display.get_monitors();
    const monitorCount = monitors.get_n_items();
    
    let monitorInfo = '';
    for (let i = 0; i < monitorCount; i++) {
        const monitor = monitors.get_item(i);
        const geometry = monitor.get_geometry();
        monitorInfo += `Monitor ${i}:\n`;
        monitorInfo += `  Geometry: ${geometry.width}x${geometry.height} at (${geometry.x}, ${geometry.y})\n`;
        monitorInfo += `  Scale Factor: ${monitor.get_scale_factor()}\n\n`;
    }

    const dialog = new Adw.MessageDialog({
        heading: _("Debug Information"),
        body: _(`System Information:
${monitorInfo}Shell Version: ${global.session.mode || 'Unknown'}
Extension Path: Available in console logs

Zone coordinates should be relative to the monitor geometry shown above.`),
        transient_for: parentWindow,
        modal: true
    });
    dialog.add_response("ok", _("OK"));
    dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED);
    dialog.connect("response", (d) => d.destroy());
    dialog.present();
}



===== FILE: ./preferences/TabBarSettingsGroup.js =====
// ./preferences/TabBarSettingsGroup.js
import Adw from 'gi://Adw'; 
import Gtk from 'gi://Gtk'; 
import Gio from 'gi://Gio'; 
import { gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 

const TAB_BAR_HEIGHT_KEY                    = 'tab-bar-height'; 
const TAB_FONT_SIZE_KEY                     = 'tab-font-size'; 
const TAB_ICON_SIZE_KEY                     = 'tab-icon-size'; 
const TAB_CORNER_RADIUS_KEY                 = 'tab-corner-radius'; 
const TAB_CLOSE_BUTTON_ICON_SIZE_KEY        = 'tab-close-button-icon-size'; 
const TAB_SPACING_KEY                       = 'tab-spacing'; 
const TAB_MIN_WIDTH_KEY                     = 'tab-min-width'; 
const TAB_MAX_WIDTH_KEY                     = 'tab-max-width'; 

export function createTabBarSettingsGroup(settings) {
    const group = new Adw.PreferencesGroup({ 
        title: _('Tab Bar Adjustments'),
        description: _('Customize the appearance and behavior of tab bars')
    }); 

    // Tab Bar Height
    const heightSpin = Gtk.SpinButton.new_with_range(16, 200, 1); 
    settings.bind(TAB_BAR_HEIGHT_KEY, heightSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const heightRow = new Adw.ActionRow({ 
        title: _('Tab Bar Height (px)'), 
        subtitle: _('Height in pixels for the tab bar'), 
        activatable_widget: heightSpin 
    });
    heightRow.add_suffix(heightSpin); 
    group.add(heightRow); 

    // Tab Font Size
    const fontSpin = Gtk.SpinButton.new_with_range(6, 72, 1); 
    settings.bind(TAB_FONT_SIZE_KEY, fontSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const fontRow = new Adw.ActionRow({ 
        title: _('Tab Font Size (px)'), 
        subtitle: _('Font size in pixels for the tab labels'), 
        activatable_widget: fontSpin 
    });
    fontRow.add_suffix(fontSpin); 
    group.add(fontRow); 

    // Tab Icon Size
    const tabIconSizeSpin = Gtk.SpinButton.new_with_range(8, 64, 1); 
    settings.bind(TAB_ICON_SIZE_KEY, tabIconSizeSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const tabIconSizeRow = new Adw.ActionRow({ 
        title: _('Tab Icon Size (px)'), 
        subtitle: _('Size for application icons in tabs'), 
        activatable_widget: tabIconSizeSpin 
    });
    tabIconSizeRow.add_suffix(tabIconSizeSpin); 
    group.add(tabIconSizeRow); 

    // Tab Corner Radius
    const tabCornerRadiusSpin = Gtk.SpinButton.new_with_range(0, 20, 1); 
    settings.bind(TAB_CORNER_RADIUS_KEY, tabCornerRadiusSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const tabCornerRadiusRow = new Adw.ActionRow({ 
        title: _('Tab Corner Radius (px)'), 
        subtitle: _('Radius for the top corners of tabs'), 
        activatable_widget: tabCornerRadiusSpin 
    });
    tabCornerRadiusRow.add_suffix(tabCornerRadiusSpin); 
    group.add(tabCornerRadiusRow); 

    // Tab Close Button Icon Size
    const tabCloseButtonIconSizeSpin = Gtk.SpinButton.new_with_range(8, 32, 1); 
    settings.bind(TAB_CLOSE_BUTTON_ICON_SIZE_KEY, tabCloseButtonIconSizeSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const tabCloseButtonIconSizeRow = new Adw.ActionRow({ 
        title: _('Tab Close Button Icon Size (px)'), 
        subtitle: _('Size for the close icon in tabs'), 
        activatable_widget: tabCloseButtonIconSizeSpin 
    });
    tabCloseButtonIconSizeRow.add_suffix(tabCloseButtonIconSizeSpin); 
    group.add(tabCloseButtonIconSizeRow); 

    // Tab Spacing
    const tabSpacingSpin = Gtk.SpinButton.new_with_range(0, 50, 1); 
    settings.bind(TAB_SPACING_KEY, tabSpacingSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const tabSpacingRow = new Adw.ActionRow({ 
        title: _('Tab Spacing (px)'), 
        subtitle: _('Gap between individual tabs'), 
        activatable_widget: tabSpacingSpin 
    });
    tabSpacingRow.add_suffix(tabSpacingSpin); 
    group.add(tabSpacingRow); 

    // Tab Min Width
    const tabMinWidthSpin = Gtk.SpinButton.new_with_range(30, 300, 5); 
    settings.bind(TAB_MIN_WIDTH_KEY, tabMinWidthSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const tabMinWidthRow = new Adw.ActionRow({ 
        title: _('Tab Minimum Width (px)'), 
        subtitle: _('Smallest width a tab can shrink to'), 
        activatable_widget: tabMinWidthSpin 
    });
    tabMinWidthRow.add_suffix(tabMinWidthSpin); 
    group.add(tabMinWidthRow); 

    // Tab Max Width
    const tabMaxWidthSpin = Gtk.SpinButton.new_with_range(50, 500, 5); 
    settings.bind(TAB_MAX_WIDTH_KEY, tabMaxWidthSpin, 'value', Gio.SettingsBindFlags.DEFAULT); 
    const tabMaxWidthRow = new Adw.ActionRow({ 
        title: _('Tab Maximum Width (px)'), 
        subtitle: _('Largest width a tab can expand to'), 
        activatable_widget: tabMaxWidthSpin 
    });
    tabMaxWidthRow.add_suffix(tabMaxWidthSpin); 
    group.add(tabMaxWidthRow); 

    return group;
}



===== FILE: ./modules/WindowManager.js =====
// modules/WindowManager.js

import Meta from 'gi://Meta';
import GLib from 'gi://GLib';
import Clutter from 'gi://Clutter';
import Mtk from 'gi://Mtk';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Shell from 'gi://Shell';
// Added for WindowTracker

import { ZoneDetector } from './ZoneDetector.js';
import { TabBar } from './TabBar.js';
const log = (context, msg) => console.log(`[TabbedTiling.WindowManager.${context}] ${msg}`);
const ALL_RESIZING_OPS = Meta.GrabOp.RESIZING_N | Meta.GrabOp.RESIZING_S |
    Meta.GrabOp.RESIZING_E | Meta.GrabOp.RESIZING_W |
    Meta.GrabOp.RESIZING_NW | Meta.GrabOp.RESIZING_NE |
    Meta.GrabOp.RESIZING_SW | Meta.GrabOp.RESIZING_SE |
    Meta.GrabOp.KEYBOARD_RESIZING_N | Meta.GrabOp.KEYBOARD_RESIZING_S |
    Meta.GrabOp.KEYBOARD_RESIZING_E | Meta.GrabOp.KEYBOARD_RESIZING_W |
    Meta.GrabOp.KEYBOARD_RESIZING_NW | Meta.GrabOp.KEYBOARD_RESIZING_NE |
    Meta.GrabOp.KEYBOARD_RESIZING_SW | Meta.GrabOp.KEYBOARD_RESIZING_SE;

export class WindowManager {
    constructor(settingsManager, highlightManager) {
        this._settingsManager = settingsManager;
        this._highlightManager = highlightManager;
        this._zoneDetector = new ZoneDetector();
        this._signalConnections = [];
        this._windowTracker = Shell.WindowTracker.get_default();
        // Added for app info

        this._snappedWindows = {};
        this._cycleIndexByZone = {};
        this._tabBars = {};
        this._windowSignalIds = new Map(); // win -> [signalId, ...]

        this._splitStates = new Map(); // Tracks { originalHeight, childZoneId, isActive }
        this._activeDisplayZones = [];
        // Zones actually used for snapping/display
    }

    _getEvasionKeyMask() {
        const keyName = this._settingsManager.getSnapEvasionKeyName();
        switch (keyName?.toLowerCase()) {
            case 'control':
                return Clutter.ModifierType.CONTROL_MASK;
            case 'alt':
                return Clutter.ModifierType.MOD1_MASK;
            case 'shift':
                return Clutter.ModifierType.SHIFT_MASK;
            case 'super':
                return Clutter.ModifierType.MOD4_MASK;
            case 'disabled':
            default:
                return 0;
        }
    }

    _rebuildActiveDisplayZones() {
        log('_rebuildActiveDisplayZones', 'Rebuilding active display zones...');
        const effectiveZones = [];
        const baseZones = this._settingsManager.getZones();

        for (const bz of baseZones) {
            // Ensure each base zone has a stable ID.
            // Using name as fallback if no explicit ID.
            // It's better if zones from settings have a truly unique 'id' field.
            // For this patch, we'll assume `bz.name` is unique or use stringify as a last resort for ID.
            const bzId = bz.id || bz.name || JSON.stringify(bz);
            // Defensive copy:
            const baseZoneCopy = { ...bz, id: bzId };
            const splitState = this._splitStates.get(bzId);

            if (splitState && splitState.isActive) {
                // Upper half of the split zone
                effectiveZones.push({
                    ...baseZoneCopy,
                    height: splitState.originalHeight / 2,

                    originalHeight: splitState.originalHeight, // Keep track for potential nested splits if ever needed
                    isSplitParent: true, // Mark as parent of a split
                    childZoneId: splitState.childZoneId
                });
                // Lower half of the split zone
                effectiveZones.push({
                    id: splitState.childZoneId,
                    monitorIndex: baseZoneCopy.monitorIndex,
                    name: `${baseZoneCopy.name || 'Zone'} (Lower)`, // TODO: i18n if needed

                    x: baseZoneCopy.x,
                    y: baseZoneCopy.y + (splitState.originalHeight / 2),
                    width: baseZoneCopy.width,
                    height: splitState.originalHeight / 2,

                    isSplitChild: true, // Mark as child of a split
                    parentZoneId: bzId
                });
            } else {
                effectiveZones.push(baseZoneCopy);
            }
        }
        this._activeDisplayZones = effectiveZones;
        log('_rebuildActiveDisplayZones', `Rebuilt with ${this._activeDisplayZones.length} active zones.`);
    }

    _rebuildAndResnapAll() {
        log('_rebuildAndResnapAll', 'Starting full rebuild and resnap...');
        // Destroy all existing tab bars
        Object.values(this._tabBars).forEach(bar => bar.destroy());
        this._tabBars = {};
        // Preserve windows that were snapped to specific zones before clearing
        const previouslySnappedWindowsByZone = { ...this._snappedWindows };
        this._snappedWindows = {};
        this._cycleIndexByZone = {};

        this._rebuildActiveDisplayZones();
        this.snapAllWindowsToZones(previouslySnappedWindowsByZone); // Pass previous state for smarter resnapping
        this.updateAllTabAppearances();
        log('_rebuildAndResnapAll', 'Full rebuild and resnap completed.');
    }

    connectSignals() {
        this._disconnectSignals();
        if (!this._settingsManager.isZoningEnabled()) {
            log('connectSignals', 'Zoning disabled.');
            return;
        }
        this._rebuildActiveDisplayZones(); // Initial build of active zones
        this._connect(global.display, 'grab-op-begin', (d, w, o) => this._onGrabOpBegin(d, w, o));
        this._connect(global.display, 'grab-op-end', (d, w, o) => this._onGrabOpEnd(d, w, o));
        this._connect(global.display, 'window-created', (d, w) => this._onWindowCreated(d, w));

        // Connect to workspace switch signal to catch state changes on inactive workspaces
        this._connect(global.workspace_manager, 'workspace-switched', () => {
            log('workspace-switched', 'Workspace switched, re-validating all tab bar visibility.');
            GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 150, () => {
                this.updateAllTabBarVisibilities();
                return GLib.SOURCE_REMOVE;
            });
        });

        log('connectSignals', 'Signals connected.');
    }

    _connect(gobj, name, cb) {
        const id = gobj.connect(name, cb);
        this._signalConnections.push({ gobj, id });
    }

    _disconnectSignals() {
        this._signalConnections.forEach(({ gobj, id }) => {
            try { gobj.disconnect(id); } catch { }
        });
        this._signalConnections = [];
    }

    _onWindowCreated(display, window) {
        if (!this._settingsManager.isZoningEnabled() ||
            !this._settingsManager.isTileNewWindowsEnabled())
            return;
        if (window.is_fullscreen() || window.get_window_type() !== Meta.WindowType.NORMAL)
            return;
        GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 150, () => {
            if (!window || typeof window.get_frame_rect !== 'function' || !window.get_compositor_private()) return GLib.SOURCE_REMOVE; // Added get_compositor_private check

            const rect = window.get_frame_rect();
            const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
            const mon = window.get_monitor();

            // Use active display zones
            const zoneDef = this._zoneDetector.findTargetZone(this._activeDisplayZones, center, mon);
            if (zoneDef) {
                this._snapWindowToZone(window, zoneDef, false);
                log('_onWindowCreated', `Auto-snapped "${window.get_title()}" into "${zoneDef.name || JSON.stringify(zoneDef)}"`);
            }

            return GLib.SOURCE_REMOVE;
        });
    }

    _onGrabOpBegin(display, window, op) {
        const isMouseMoving = (op & Meta.GrabOp.MOVING) !== 0;
        const isKeyboardMoving = (op & Meta.GrabOp.KEYBOARD_MOVING) !== 0;

        const evasionKeyMask = this._getEvasionKeyMask();
        const [, , mods] = global.get_pointer();
        const isEvasionKeyHeld = evasionKeyMask !== 0 && (mods & evasionKeyMask) !== 0;

        delete window._tabbedTilingEvasionBypass;
        if (isEvasionKeyHeld) {
            window._tabbedTilingEvasionBypass = true;
            const keyName = this._settingsManager.getSnapEvasionKeyName();
            log('_onGrabOpBegin', `${keyName} key is held for "${window.get_title()}", bypassing highlights and original rect store.`);
            this._highlightManager?.stopUpdating();
            return;
        }

        if (!(isMouseMoving || isKeyboardMoving)) {
            log('_onGrabOpBegin', `Operation is not a move (op: ${op}), stopping highlights and skipping further setup.`);
            this._highlightManager?.stopUpdating();
            return;
        }

        if (!window || !window.get_compositor_private() || window.is_fullscreen() || window.get_window_type() !== Meta.WindowType.NORMAL) // Added get_compositor_private check
            return;
        if (this._settingsManager.isRestoreOnUntileEnabled() && !window._tabbedTilingOriginalRect) {
            window._tabbedTilingOriginalRect = window.get_frame_rect();
            log('_onGrabOpBegin', `Stored original rect for "${window.get_title()}" during normal move.`);
        }
        this._highlightManager?.startUpdating();
    }

    _onGrabOpEnd(display, window, op) {

        this._highlightManager?.stopUpdating();
        const wasEvasionBypassActiveAtStart = window._tabbedTilingEvasionBypass;
        delete window._tabbedTilingEvasionBypass;

        const evasionKeyMask = this._getEvasionKeyMask();
        const [, , modsAtEnd] = global.get_pointer();
        const isEvasionKeyHeldAtEnd = evasionKeyMask !== 0 && (modsAtEnd & evasionKeyMask) !== 0;
        if (isEvasionKeyHeldAtEnd || wasEvasionBypassActiveAtStart) {
            const keyName = this._settingsManager.getSnapEvasionKeyName();
            log('_onGrabOpEnd', `${keyName} key is (or was at start) held for "${window.get_title()}", bypassing snap logic. Window remains at current pos.`);
            if (window._tabbedTilingIsZoned) {
                this._unsnapWindow(window, /* keepCurrentPosition = */ true);
            } else {
                delete window._tabbedTilingOriginalRect;
            }
            return;
        }

        if (op === Meta.GrabOp.MOVING || op === Meta.GrabOp.KEYBOARD_MOVING) {
            log('_onGrabOpEnd', `Operation is MOVING or KEYBOARD_MOVING (op: ${op}), proceeding to normal snap logic.`);
        } else if ((op & ALL_RESIZING_OPS) !== 0) {
            log('_onGrabOpEnd', `Operation is RESIZING (op: ${op}) and not a direct move type, skipping snap.`);
            return;
        } else {
            log('_onGrabOpEnd', `Operation is UNKNOWN or not a snappable type (op: ${op}), skipping snap.`);
            return;
        }


        if (!this._settingsManager.isZoningEnabled()) return;
        if (!window || !window.get_compositor_private() || window.is_fullscreen() || window.get_window_type() !== Meta.WindowType.NORMAL) { // Added get_compositor_private check
            this._unsnapWindow(window);
            return;
        }


        const [pointerX, pointerY] = global.get_pointer();
        const hitRect = new Mtk.Rectangle({ x: pointerX, y: pointerY, width: 1, height: 1 });
        let mon = global.display.get_monitor_index_for_rect(hitRect);
        if (mon < 0)
            mon = window.get_monitor();
        if (mon < 0 || mon >= Main.layoutManager.monitors.length) {
            mon = Main.layoutManager.primaryIndex;
        }


        const center = { x: pointerX, y: pointerY };
        // Use active display zones
        const zoneDef = this._zoneDetector.findTargetZone(this._activeDisplayZones, center, mon);
        if (zoneDef) {
			this._snapWindowToZone(window, zoneDef, true);

            // MODIFIED LOG LINE STARTS HERE
            const app = this._windowTracker.get_window_app(window);
            const appName = app ? app.get_name() : 'N/A'; // Default tab name
            const appId = app ?
            app.get_id() : 'N/A';
            const wmClass = window.get_wm_class() || 'N/A';
            const wmClassInstance = window.get_wm_class_instance() || 'N/A';
            console.log(`[DEBUG] Window "${window.get_title()}" - Old zone: ${window._tabbedTilingZoneId}, New zone: ${zoneDef ? (zoneDef.id || zoneDef.name) : 'none'}`);
        } else {
            this._unsnapWindow(window);
        }
    }

    _getZoneTabBar(zoneId, monitorIndex, zoneDef) {
		let bar = this._tabBars[zoneId];
		if (!bar) {
		    bar = new TabBar(zoneId, zoneDef, win => this._activateWindow(zoneId, win), this._settingsManager, this);
		    this._tabBars[zoneId] = bar;
		    Main.uiGroup.add_child(bar);
		}

		const monitor = Main.layoutManager.monitors[monitorIndex];
		const x = monitor.x + zoneDef.x;
		// Already using monitor geometry
		const y = monitor.y + Math.max(0, zoneDef.y); // Already using monitor geometry

		const height = this._settingsManager.getTabBarHeight();
		bar.set_position(x, y);
		bar.set_size(zoneDef.width, height);
		bar.set_style(`height: ${height}px;`);
		return bar;
	}

    snapAllWindowsToZones(previouslySnappedWindowsByZone = null) {
        if (!this._settingsManager.isZoningEnabled()) return;
        log('snapAllWindowsToZones', `Snapping all windows. Previously snapped: ${previouslySnappedWindowsByZone ? Object.keys(previouslySnappedWindowsByZone).length : 0} zones.`);
        // Ensure active zones are current
        if (this._activeDisplayZones.length === 0) {
            this._rebuildActiveDisplayZones();
        }
        const currentActiveZones = this._activeDisplayZones;
        // If previous state is provided, try to restore windows to their *new* corresponding zones
        if (previouslySnappedWindowsByZone) {
            for (const oldZoneId in previouslySnappedWindowsByZone) {
                const windowsInOldZone = previouslySnappedWindowsByZone[oldZoneId];
                const splitState = this._splitStates.get(oldZoneId); // Check if the *original* zone was split

                windowsInOldZone.forEach(win => {
                    // MODIFIED LINE BELOW
                    if (!win || !win.get_compositor_private() || win.is_fullscreen() || win.get_window_type() !== Meta.WindowType.NORMAL) return;


                    let targetZoneDef = null;
                    if (splitState && splitState.isActive) {
                        // If the original zone is now split, windows that were in it are considered for the upper half by default
                        targetZoneDef = currentActiveZones.find(z => z.id === oldZoneId && z.isSplitParent);
                    } else {
                        // If not split, or if it was a child zone that got removed (handled by parent merge)
                        // Try to find the zone by its
                        // ID (which might have been a child ID)
                        targetZoneDef = currentActiveZones.find(z => z.id === oldZoneId);
                    }

                    if (targetZoneDef) {

                        this._snapWindowToZone(win, targetZoneDef, false);
                    } else {
                        // Fallback: try to snap based on current position if no direct mapping found
                        this._snapWindowByCurrentPosition(win, currentActiveZones);
                    }
                });
            }
        }

        // Snap any remaining/newly created windows not handled by the above
        global.get_window_actors().forEach(actor => {
            const win = actor.get_meta_window();
            // Only process if not already snapped by the logic above
            if (!win || !win.get_compositor_private() || win._tabbedTilingIsZoned || win.is_fullscreen() || win.get_window_type() !== Meta.WindowType.NORMAL) //
                // Added get_compositor_private check
                return;
            this._snapWindowByCurrentPosition(win, currentActiveZones);
        });
        log('snapAllWindowsToZones', 'Finished snapping all windows.');
    }

    _snapWindowByCurrentPosition(win, zonesToSearch) {
		const rect = win.get_frame_rect();
		const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
		let mon = win.get_monitor();
		if (mon < 0 || mon >= Main.layoutManager.monitors.length) {
		    mon = Main.layoutManager.primaryIndex;
		}

		let zoneDef = this._zoneDetector.findTargetZone(zonesToSearch, center, mon);
		if (!zoneDef) { // Fallback to closest zone on the same monitor
		    // Change from workArea to full monitor geometry
		    const monitor = Main.layoutManager.monitors[mon];
		    // Changed from wa
		    let bestDistanceSq = Infinity;
		    let closestZone = null;
		    zonesToSearch.filter(z => z.monitorIndex === mon).forEach(zDef => {
		        const zoneCenterX = monitor.x + zDef.x + zDef.width / 2; // Use monitor.x
		        const zoneCenterY = monitor.y + zDef.y + zDef.height / 2; // Use monitor.y
		        const dx = zoneCenterX - center.x;
		        const dy = zoneCenterY - center.y;
		        const distSq = dx * dx + dy * dy;
		        if (distSq <
		            bestDistanceSq) {
		            bestDistanceSq = distSq;
		            closestZone = zDef;
		        }
		    });
		    zoneDef = closestZone;
		}
		if (zoneDef) this._snapWindowToZone(win, zoneDef, false);
	}

	_snapWindowToZone(window, zoneDef, isGrabOpContext = false) {
        const zoneId = zoneDef.id ||
        zoneDef.name || JSON.stringify(zoneDef);
        const oldZoneId = window._tabbedTilingZoneId;

        if (oldZoneId && oldZoneId !== zoneId) {
            // Directly access existing tab bar without repositioning it
            const oldTabBar = this._tabBars[oldZoneId];
            if (oldTabBar) {
                oldTabBar.removeWindow(window);
            }
            this._snappedWindows[oldZoneId] = (this._snappedWindows[oldZoneId] || []).filter(w => w !== window);
        }

        if (window.get_maximized && window.get_maximized())
            window.unmaximize(Meta.MaximizeFlags.BOTH);
        if (this._settingsManager.isRestoreOnUntileEnabled() && !window._tabbedTilingOriginalRect) {
            window._tabbedTilingOriginalRect = window.get_frame_rect();
            log('_snapWindowToZone', `Stored original rect for "${window.get_title()}"`);
        }

        this._snappedWindows[zoneId] = this._snappedWindows[zoneId] || [];
        if (!this._snappedWindows[zoneId].includes(window)) {
            this._snappedWindows[zoneId].push(window);
            this._connectWindowStateSignals(window);
        }
        this._cycleIndexByZone[zoneId] = (this._snappedWindows[zoneId].length - 1);
        window._tabbedTilingIsZoned = true;
        window._tabbedTilingZoneId = zoneId; // zoneId here is zoneDef.id

        const monitor = Main.layoutManager.monitors[zoneDef.monitorIndex];
        const barHeight = this._settingsManager.getTabBarHeight();
        const minWindowDim = 50;
        const zoneGap = this._settingsManager.getZoneGapSize();
        let gapPosOffset = 0; let gapSizeReduction = 0;
        if (zoneGap > 0) {
            gapPosOffset = Math.floor(zoneGap / 2);
            gapSizeReduction = zoneGap;
        }

        const slotX = monitor.x + zoneDef.x;
        let slotW = Math.min(zoneDef.width, (monitor.x + monitor.width) - slotX);
        slotW = Math.max(slotW, minWindowDim);
        // Calculate the Y position for the content area (below the tab bar, accounting for gap)
        // The tab bar is placed at the top of the zone definition, relative to monitor.y
        // We need to ensure the tab bar itself also respects the top gap.
        const tabBarY = monitor.y + zoneDef.y + zoneGap;
		const slotContentY = monitor.y + zoneDef.y + zoneGap + barHeight;
		let slotH = Math.min(zoneDef.height - barHeight - zoneGap, (monitor.y + monitor.height) - slotContentY);

        slotH = Math.max(slotH, minWindowDim);
        const gappedWindowX = slotX + gapPosOffset;
        let gappedWindowW = Math.max(slotW - gapSizeReduction, minWindowDim);
		const gappedWindowY = slotContentY;
		let gappedWindowH = Math.max(slotH - gapSizeReduction, minWindowDim);

        // The tabBarX is already adjusted by gapPosOffset from earlier.
        const tabBarX = monitor.x + zoneDef.x + gapPosOffset; // This line was already okay.


        const tabBarW = gappedWindowW;
        // Tab bar width should align with gapped window width
        window.move_resize_frame(false, gappedWindowX, gappedWindowY, gappedWindowW, gappedWindowH);
        const tabBar = this._getZoneTabBar(zoneId, zoneDef.monitorIndex, zoneDef);
        tabBar.set_position(tabBarX, tabBarY);
        tabBar.set_size(tabBarW, barHeight);
        tabBar.set_style(`height: ${barHeight}px;`);
        if (!isGrabOpContext) {
            GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 150, () => {
                if (window && window.get_compositor_private() && typeof window.get_frame_rect === 'function' &&
                    window._tabbedTilingZoneId === zoneId && !window.is_fullscreen() &&
                    window.get_maximized() === Meta.MaximizeFlags.NONE) {

                    const currentRect = window.get_frame_rect();
                    if (currentRect.x !== gappedWindowX || currentRect.y !== gappedWindowY ||
                        currentRect.width !== gappedWindowW || currentRect.height !== gappedWindowH) {
                        log('_snapWindowToZone[DelayedCheck]', `Window "${window.get_title()}"
                        mismatch. Re-applying.`);
                        window.move_resize_frame(false, gappedWindowX, gappedWindowY, gappedWindowW, gappedWindowH);
                        const delayedTabBar = this._getZoneTabBar(zoneId, zoneDef.monitorIndex, zoneDef);
                        delayedTabBar.set_position(tabBarX, tabBarY);
                        delayedTabBar.set_size(tabBarW, barHeight);
                    }
                }
                return GLib.SOURCE_REMOVE;
            });
        }

        this.updateAllTabBarVisibilities();
        tabBar.addWindow(window);
        this._activateWindow(zoneId, window);
	}

    _unsnapWindow(window, keepCurrentPosition = false) {
        const oldZoneId = window._tabbedTilingZoneId;
        // Only proceed if it was actually zoned OR if we're explicitly keeping position (e.g. Ctrl-drag of a non-zoned window needs its OriginalRect cleared)
        if (!oldZoneId && !keepCurrentPosition) {
            return;
        }
        log('_unsnapWindow', `Unsnapping "${window.get_title()}" from zone "${oldZoneId || 'N/A'}". keepCurrentPosition=${keepCurrentPosition}`);
        if (!keepCurrentPosition && this._settingsManager.isRestoreOnUntileEnabled() && window._tabbedTilingOriginalRect) {
            const o = window._tabbedTilingOriginalRect;
            window.move_resize_frame(false, o.x, o.y, o.width, o.height);
            delete window._tabbedTilingOriginalRect;
        } else if (keepCurrentPosition) {
            delete window._tabbedTilingOriginalRect;
        }

        if (oldZoneId) {
            this._disconnectWindowStateSignals(window);
            delete window._tabbedTilingIsZoned;
            delete window._tabbedTilingZoneId;

            const oldZoneDef = this._activeDisplayZones.find(z => z.id === oldZoneId);
            // Find from active zones
            if (oldZoneDef) {
                const tabBar = this._tabBars[oldZoneId];
                if (tabBar) {
                    tabBar.removeWindow(window);
                }
            }
            this._snappedWindows[oldZoneId] = (this._snappedWindows[oldZoneId] || []).filter(w => w !== window);
            if (this._snappedWindows[oldZoneId] && this._snappedWindows[oldZoneId].length === 0) {
                if (this._tabBars[oldZoneId]) {
                    this._tabBars[oldZoneId].destroy();
                    delete this._tabBars[oldZoneId];
                }
                delete this._cycleIndexByZone[oldZoneId];
            }
            this.updateAllTabBarVisibilities();
        }
    }

    _onWindowStateChanged() {
        GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, 50, () => {
            this.updateAllTabBarVisibilities();
            return GLib.SOURCE_REMOVE;
        });
    }

    _connectWindowStateSignals(window) {
        if (!window || this._windowSignalIds.has(window)) {
            return;
        }

        const signalIds = [];
        const handler = () => this._onWindowStateChanged();

        signalIds.push(window.connect('notify::fullscreen', handler));
        signalIds.push(window.connect('notify::maximized-horizontally', handler));
        signalIds.push(window.connect('notify::maximized-vertically', handler));

        this._windowSignalIds.set(window, signalIds);
        log('_connectWindowStateSignals', `Connected state signals for "${window.get_title()}".`);
    }

    _disconnectWindowStateSignals(window) {
        if (!window || !this._windowSignalIds.has(window)) {
            return;
        }

        const signalIds = this._windowSignalIds.get(window);
        signalIds.forEach(id => {
            try {
                window.disconnect(id);
            } catch (e) {
                // Ignore errors, window might already be gone
            }
        });

        this._windowSignalIds.delete(window);
        log('_disconnectWindowStateSignals', `Disconnected state signals for "${window.get_title()}".`);
    }

    updateAllTabBarVisibilities() {
        let anyWindowIsMaximizedOrFullscreen = false;
        const allWindows = global.get_window_actors().map(a => a.get_meta_window());

        for (const win of allWindows) {
            if (win && (win.get_maximized() || win.is_fullscreen())) {
                anyWindowIsMaximizedOrFullscreen = true;
                break;
            }
        }

        log('updateAllTabBarVisibilities', `Any window maximized/fullscreen? ${anyWindowIsMaximizedOrFullscreen}`);

        for (const zoneId in this._tabBars) {
            const bar = this._tabBars[zoneId];
            if (anyWindowIsMaximizedOrFullscreen) {
                if (bar.visible) {
                    bar.visible = false;
                }
            } else {
                const windowsInZone = this._snappedWindows[zoneId] || [];
                const shouldBeVisible = windowsInZone.length > 0;
                if (bar.visible !== shouldBeVisible) {
                    bar.visible = shouldBeVisible;
                }
            }
        }
    }

    cycleWindowsInCurrentZone() {
        const focus = global.display.focus_window;
        if (!focus || !focus._tabbedTilingZoneId || !focus.get_compositor_private()) { // Added get_compositor_private check
            log('cycle', 'No valid zoned window focused; aborting.');
            return;
        }
        const zoneId = focus._tabbedTilingZoneId;
        const list = this._snappedWindows[zoneId] || [];
        if (list.length < 2) {
            log('cycle', `Zone "${zoneId}" has ${list.length} window(s); skipping cycle.`);
            return;
        }
        let idx = (this._cycleIndexByZone[zoneId] + 1) % list.length;
        this._cycleIndexByZone[zoneId] = idx;
        const nextWin = list[idx];
        if (!nextWin || !nextWin.get_compositor_private()) { log('cycle', 'Next window in cycle is invalid.'); return;
        } // Added check
        log('cycle', `Cycling to [${idx}] "${nextWin.get_title()}" in zone "${zoneId}".`);
        this._activateWindow(zoneId, nextWin);
    }

    cycleWindowsInCurrentZoneBackward() {
        const focus = global.display.focus_window;
        if (!focus || !focus._tabbedTilingZoneId || !focus.get_compositor_private()) { // Added get_compositor_private check
            log('cycle-backward', 'No valid zoned window focused; aborting.');
            return;
        }
        const zoneId = focus._tabbedTilingZoneId;
        const list = this._snappedWindows[zoneId] || [];
        if (list.length < 2) {
            log('cycle-backward', `Zone "${zoneId}" has ${list.length} window(s); skipping cycle.`);
            return;
        }
        let idx = (this._cycleIndexByZone[zoneId] - 1 + list.length) % list.length;
        this._cycleIndexByZone[zoneId] = idx;
        const prevWin = list[idx];
        if (!prevWin || !prevWin.get_compositor_private()) { log('cycle-backward', 'Previous window in cycle is invalid.'); return;
        } // Added check
        log('cycle-backward', `Cycling backward to [${idx}] "${prevWin.get_title()}" in zone "${zoneId}".`);
        this._activateWindow(zoneId, prevWin);
    }

    _activateWindow(zoneId, window) {
        if (!window || !window.get_compositor_private()) { // Added get_compositor_private check
            log('_activateWindow', 'Attempted to activate an invalid window.');
            return;
        }
        const list = this._snappedWindows[zoneId] || [];
        const currentWindowIndex = list.indexOf(window);
        if (currentWindowIndex !== -1) {
            this._cycleIndexByZone[zoneId] = currentWindowIndex;
        }
        const now = global.get_current_time();
        window.activate(now);
        this._tabBars[zoneId]?.highlightWindow(window);
    }

    cleanupWindowProperties() {
        global.get_window_actors().forEach(actor => {
            const w = actor.get_meta_window();
            if (w) {
                delete w._tabbedTilingIsZoned;
                delete w._tabbedTilingOriginalRect;
                delete
                w._tabbedTilingZoneId;
                delete w._tabbedTilingEvasionBypass;
            }
        });
    }

    updateAllTabAppearances() {
        log('updateAllTabAppearances', 'Requesting update for appearance of all tab bars.');
        for (const zoneId in this._tabBars) {
            const tabBar = this._tabBars[zoneId];
            if (tabBar && typeof tabBar.refreshTabVisuals === 'function') {
                const zoneDef = this._activeDisplayZones.find(z => z.id === zoneId);
                log('updateAllTabAppearances', `Refreshing visuals for tab bar: ${zoneId}, zoneDef found: ${!!zoneDef}`);
                if (zoneDef) {
                    const monitor = Main.layoutManager.monitors[zoneDef.monitorIndex];
                    const barHeight = this._settingsManager.getTabBarHeight();
                    const zoneGap = this._settingsManager.getZoneGapSize();
                    const gapPosOffset = zoneGap > 0 ? Math.floor(zoneGap / 2) : 0;
                    const tabBarX = monitor.x + zoneDef.x + gapPosOffset;
                    const tabBarY = monitor.y + zoneDef.y + zoneGap;

                    const minWindowDim = 50;
                    let slotW = Math.min(zoneDef.width, (monitor.x + monitor.width) - (monitor.x + zoneDef.x));
                    slotW = Math.max(slotW, minWindowDim);
                    let gappedWindowW = slotW - (zoneGap > 0 ? zoneGap : 0);
                    gappedWindowW = Math.max(gappedWindowW, minWindowDim);
                    const tabBarW = gappedWindowW;
                    tabBar._zoneDef = zoneDef;
                    tabBar.set_position(tabBarX, tabBarY);
                    tabBar.set_size(tabBarW, barHeight);
                    tabBar.set_style(`height: ${barHeight}px;`);
                    tabBar.refreshTabVisuals();
                }
            }
        }
        log('updateAllTabAppearances', 'Finished updating all tab appearances.');
    }

    toggleZoneSplit(parentZoneIdToToggle) {
        log('toggleZoneSplit', `Toggling split for zone ID: ${parentZoneIdToToggle}`);
        const baseZoneDef = this._settingsManager.getZones().find(z => (z.id || z.name || JSON.stringify(z)) === parentZoneIdToToggle);
        if (!baseZoneDef) {
            log('toggleZoneSplit', `Error: Base zone definition not found for ID: ${parentZoneIdToToggle}`);
            return;
        }
        // Ensure baseZoneDef has an 'id' if it's relying on name/stringify
        const parentId = baseZoneDef.id ||
        baseZoneDef.name || JSON.stringify(baseZoneDef);

        let splitState = this._splitStates.get(parentId);

        if (splitState && splitState.isActive) { // MERGE
            log('toggleZoneSplit', `Merging zone ${parentId} (child: ${splitState.childZoneId})`);
            // Windows in childZoneId will be re-evaluated by snapAllWindowsToZones and should move to the parent
            this._splitStates.delete(parentId);
        } else { // SPLIT
            const originalHeight = baseZoneDef.height;
            // This should be the full height from gsettings
            const childZoneId = parentId + "_lower";
            // Simple ID generation
            log('toggleZoneSplit', `Splitting zone ${parentId}. Original height: ${originalHeight}. Child ID: ${childZoneId}`);
            this._splitStates.set(parentId, {
                originalHeight: originalHeight, // Store the original full height
                childZoneId: childZoneId,
                isActive: true
            });
        }
        this._rebuildAndResnapAll();
    }

    destroy() {
        this._disconnectSignals();
        const allWindowsWithSignals = [...this._windowSignalIds.keys()];
        allWindowsWithSignals.forEach(win => this._disconnectWindowStateSignals(win));
        this._windowSignalIds.clear();
        Object.values(this._tabBars).forEach(bar => bar.destroy());
        this._tabBars = {};
        this._splitStates.clear();
        this._activeDisplayZones = [];
        this.cleanupWindowProperties();
        log('destroy', 'Destroyed.');
    }

    // Called from extension.js enable/disable or when settings change fundamentally
    refreshZonesAndLayout() {
        this._splitStates.clear();
        // Clear any previous dynamic splits
        this._rebuildAndResnapAll();
    }
}



===== FILE: ./modules/TabDragger.js =====
// ./modules/TabDragger.js
import GLib from 'gi://GLib';
import Clutter from 'gi://Clutter';
import St from 'gi://St';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

const DRAG_THRESHOLD = 10;
const HOLD_TIMEOUT = 250; // Milliseconds

export class TabDragger {
    constructor(tabBar, onTabClicked) {
        this._tabBar = tabBar;
        this._onTabClicked = onTabClicked; // To reactivate tab after drop
        this._dragInfo = null;
        this._pressTimeoutId = 0;
    }

    initPointerHandlers(actor, win) {
        actor._pressEventDetails = null;
        actor.connect('button-press-event', (a, event) => {
            const source = event.get_source();
            if (source && typeof source.has_style_class_name === 'function' && source.has_style_class_name('zone-tab-close-button')) {
                return Clutter.EVENT_PROPAGATE;
            }
            if (event.get_button() !== 1) return Clutter.EVENT_PROPAGATE;

            actor.grab_key_focus();

            if (actor._pressTimeoutId) GLib.Source.remove(actor._pressTimeoutId); 

            const [pressEventX, pressEventY] = event.get_coords();
            actor._pressEventDetails = { time: event.get_time(), x: pressEventX, y: pressEventY, rawEvent: event }; 

            actor._pressTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, HOLD_TIMEOUT, () => { 
                actor._pressTimeoutId = 0; 
                if (actor._pressEventDetails) { 
                    this._beginDrag(actor, actor._pressEventDetails.rawEvent); 
                }
                return GLib.SOURCE_REMOVE; 
            });
            return Clutter.EVENT_STOP; 
        });

        actor.connect('motion-event', (a, event) => {
            if ((event.get_state() & Clutter.ModifierType.BUTTON1_MASK) && actor._pressEventDetails) { 
                if (!this._dragInfo || !this._dragInfo.isDragging) { 
                    const [currentX, currentY] = event.get_coords();
                    const { x: startX, y: startY } = actor._pressEventDetails;
                    if (Math.abs(currentX - startX) > DRAG_THRESHOLD || Math.abs(currentY - startY) > DRAG_THRESHOLD) { 
                        if (actor._pressTimeoutId) { 
                            GLib.Source.remove(actor._pressTimeoutId); 
                            actor._pressTimeoutId = 0; 
                        }
                        this._beginDrag(actor, actor._pressEventDetails.rawEvent); 
                    }
                }
            }
            return Clutter.EVENT_PROPAGATE; 
        });

        actor.connect('button-release-event', (a, event) => {
            const source = event.get_source();
            if (source && typeof source.has_style_class_name === 'function' && source.has_style_class_name('zone-tab-close-button')) {
                return Clutter.EVENT_PROPAGATE;
            }
            if (event.get_button() !== 1) return Clutter.EVENT_PROPAGATE; 

            const wasPressPending = !!actor._pressTimeoutId; 
            if (actor._pressTimeoutId) { 
                GLib.Source.remove(actor._pressTimeoutId); 
                actor._pressTimeoutId = 0; 
            }

            const clickOccurred = wasPressPending && (!this._dragInfo || !this._dragInfo.isDragging); 

            if (clickOccurred) {
                this._onTabClicked(win); 
            }
            actor._pressEventDetails = null; 
            // If a drag operation was completed, _onDragRelease would handle it.
            // This primarily handles the click scenario.
            return Clutter.EVENT_STOP; 
        });
    }

    _beginDrag(actor, pressEvent) {
        if (this._dragInfo && this._dragInfo.isDragging) return; 
        if (!actor || actor.get_parent() !== this._tabBar) { 
            console.warn("TabDragger: _beginDrag called for an actor not in the managed TabBar or null actor.");
            if (actor && actor._pressTimeoutId) GLib.Source.remove(actor._pressTimeoutId); 
            if (actor) actor._pressEventDetails = null; 
            return; 
        }

        if (actor._pressTimeoutId) { 
            GLib.Source.remove(actor._pressTimeoutId); 
            actor._pressTimeoutId = 0; 
        }
        actor._pressEventDetails = null; 

        const [pointerScreenX, pointerScreenY] = pressEvent.get_coords(); 
        const actorAllocationInTabBar = actor.get_allocation_box(); 
        const [tabBarScreenX, tabBarScreenY] = this._tabBar.get_transformed_position(); 

        const actorInitialScreenX = tabBarScreenX + actorAllocationInTabBar.x1; 
        const actorInitialScreenY = tabBarScreenY + actorAllocationInTabBar.y1; 

        const originalIndex = this._tabBar.get_children().indexOf(actor); 

        const actorWidth = actor.get_width(); 
        const actorHeight = actor.get_height(); 
        const slotActor = new St.Bin({ style_class: 'zone-tab-drag-slot', width: actorWidth, height: actorHeight }); 

        actor.set_opacity(200); 
        this._tabBar.remove_child(actor); 
        Main.uiGroup.add_child(actor); 
        actor.set_position(actorInitialScreenX, actorInitialScreenY); 
        try { 
            if (typeof actor.raise_top === 'function') { 
                actor.raise_top(); 
            } else {
                const parent = actor.get_parent(); 
                if (parent && typeof parent.set_child_above_sibling === 'function') { 
                    parent.set_child_above_sibling(actor, null); 
                }
            }
        } catch (e) {
            console.error("TabDragger: Error trying to raise actor.", e); 
        }

        this._tabBar.insert_child_at_index(slotActor, originalIndex); 
        this._dragInfo = { 
            isDragging: true, 
            draggedActor: actor, 
            slotActor: slotActor, 
            originalIndex: originalIndex, 
            actorGrabOffsetX: pointerScreenX - actorInitialScreenX, 
            actorGrabOffsetY: pointerScreenY - actorInitialScreenY, 
            motionId: global.stage.connect('motion-event', this._onDragMotion.bind(this)), 
            releaseId: global.stage.connect('button-release-event', this._onDragRelease.bind(this)), 
        };
        this._tabBar.requestLayoutUpdate(true); 
    }

    _onDragMotion(stage, event) {
        if (!this._dragInfo || !this._dragInfo.isDragging) return Clutter.EVENT_PROPAGATE; 
        const [currentPointerScreenX, currentPointerScreenY] = event.get_coords(); 
        this._dragInfo.draggedActor.set_position( 
            currentPointerScreenX - this._dragInfo.actorGrabOffsetX,
            currentPointerScreenY - this._dragInfo.actorGrabOffsetY
        );
        const [tabBarScreenX, ] = this._tabBar.get_transformed_position(); 
        const pointerXInTabBar = currentPointerScreenX - tabBarScreenX; 

        let newSlotIndex = 0; 
        const currentChildren = this._tabBar.get_children(); 
        const currentSlotActualIndex = currentChildren.indexOf(this._dragInfo.slotActor); 

        if (currentSlotActualIndex === -1) { 
            console.error("TabDragger: Slot actor not found in TabBar during drag motion."); 
            this.cancelDrag(true); 
            return Clutter.EVENT_STOP; 
        }

        let visualChildIndex = 0; 
        for (let i = 0; i < currentChildren.length; i++) { 
            const child = currentChildren[i]; 
            if (child === this._dragInfo.slotActor) continue; 

            const childAllocation = child.get_allocation_box(); 
            const childMidX = childAllocation.x1 + childAllocation.get_width() / 2; 
            if (pointerXInTabBar > childMidX) { 
                newSlotIndex = visualChildIndex + 1; 
            }
            visualChildIndex++; 
        }

        if (currentSlotActualIndex !== newSlotIndex) { 
            const tempSlot = this._dragInfo.slotActor; 
            if (tempSlot.get_parent() === this._tabBar) { 
                this._tabBar.set_child_at_index(tempSlot, newSlotIndex); 
            } else {
                console.error("TabDragger: Slot actor lost parentage during drag motion."); 
                this.cancelDrag(true); 
                return Clutter.EVENT_STOP; 
            }
            this._tabBar.requestLayoutUpdate(true); 
        }
        return Clutter.EVENT_STOP; 
    }

    _onDragRelease(stage, event) {
        if (!this._dragInfo || !this._dragInfo.isDragging || event.get_button() !== 1) { 
            if (this._dragInfo) { 
                if (this._dragInfo.motionId) global.stage.disconnect(this._dragInfo.motionId); 
                if (this._dragInfo.releaseId) global.stage.disconnect(this._dragInfo.releaseId); 
            }
            this._dragInfo = null; 
            return Clutter.EVENT_PROPAGATE; 
        }

        const { draggedActor, slotActor, motionId, releaseId, originalIndex } = this._dragInfo; 
        if (motionId) global.stage.disconnect(motionId); 
        if (releaseId) global.stage.disconnect(releaseId); 

        let finalInsertionIndex = -1; 
        if (slotActor && slotActor.get_parent() === this._tabBar) { 
            finalInsertionIndex = this._tabBar.get_children().indexOf(slotActor); 
        } else if (slotActor) {
            console.warn("TabDragger: Slot actor not parented correctly at drag release."); 
            finalInsertionIndex = originalIndex; // Fallback to original index [cite: 323]
        } else {
            finalInsertionIndex = originalIndex; 
        }

        if (slotActor) { 
            if (slotActor.get_parent() === this._tabBar) this._tabBar.remove_child(slotActor); 
            slotActor.destroy(); 
        }

        if (draggedActor) { 
            if (draggedActor.get_parent() === Main.uiGroup) Main.uiGroup.remove_child(draggedActor); 
            const numChildrenAfterSlotRemoval = this._tabBar.get_n_children(); 
            const insertionIndex = Math.max(0, Math.min(finalInsertionIndex, numChildrenAfterSlotRemoval)); 

            this._tabBar.insert_child_at_index(draggedActor, insertionIndex); 
            draggedActor.set_opacity(255); 
            draggedActor.set_translation(0, 0, 0); 

            const droppedWindow = draggedActor._tabWindow; 
            if (droppedWindow) { 
                this._onTabClicked(droppedWindow); 
                if (draggedActor.can_focus) draggedActor.grab_key_focus(); 
            }
        }

        this._dragInfo = null; 
        this._tabBar.requestLayoutUpdate(true); 
        return Clutter.EVENT_STOP; 
    }

    cancelDrag(forceCleanup = false) {
        // Clean up any pending press timeouts on individual tab actors
        this._tabBar.getTabActors().forEach(actor => { 
            if (actor._pressTimeoutId) {
                GLib.Source.remove(actor._pressTimeoutId);
                actor._pressTimeoutId = 0;
            }
            actor._pressEventDetails = null;
        });

        if (this._pressTimeoutId) { 
            GLib.Source.remove(this._pressTimeoutId); 
            this._pressTimeoutId = 0; 
        }

        if (this._dragInfo && (this._dragInfo.isDragging || forceCleanup)) { 
            const { draggedActor, slotActor, originalIndex, motionId, releaseId } = this._dragInfo; 
            if (motionId) global.stage.disconnect(motionId); 
            if (releaseId) global.stage.disconnect(releaseId); 

            if (draggedActor) { 
                if (draggedActor.get_parent() === Main.uiGroup) { 
                    Main.uiGroup.remove_child(draggedActor); 
                    // Check if tab still exists in TabBar's data model
                    const isStillManaged = this._tabBar.hasWindow(draggedActor._tabWindow); 
                    if (!forceCleanup && isStillManaged && this._tabBar.get_parent()) { 
                        const childrenCount = this._tabBar.get_n_children(); 
                        const reinsertIdx = Math.min(originalIndex, childrenCount); 
                        if (draggedActor.get_parent() !== this._tabBar) { 
                           this._tabBar.insert_child_at_index(draggedActor, reinsertIdx); 
                        }
                    } else if (!isStillManaged && !forceCleanup) { // If no longer managed (e.g. window closed during drag)
                        //draggedActor.destroy(); // The TabBar's removeWindow should handle this
                    }
                }
                draggedActor.set_opacity(255); 
                draggedActor.set_translation(0, 0, 0); 
            }
            if (slotActor) { 
                if (slotActor.get_parent() === this._tabBar) this._tabBar.remove_child(slotActor); 
                slotActor.destroy(); 
            }
        }
        this._dragInfo = null; 
        if (this._tabBar.get_parent() && (forceCleanup || (this._tabBar.visible && this._tabBar.get_n_children() > 0))) { 
            this._tabBar.requestLayoutUpdate(true); 
        }
    }

    isDragging() {
        return this._dragInfo && this._dragInfo.isDragging;
    }

    getDraggedActor() {
        return this._dragInfo ? this._dragInfo.draggedActor : null;
    }


    destroy() {
        this.cancelDrag(true);
        // Any other specific cleanup for TabDragger
    }
}



===== FILE: ./modules/ZoneDetector.js =====
import * as Main from 'resource:///org/gnome/shell/ui/main.js'; 
const log = (prefix, msg) => console.log(`[TabbedTilingPrefs.ZoneDetector.${prefix}] ${msg}`); 

function isPointInsideRect(point, rect) {
    const check = point.x >= rect.x && point.x <= rect.x + rect.width && 
                  point.y >= rect.y && point.y <= rect.y + rect.height; 
    return check; 
}

export class ZoneDetector {
    constructor() {
        // log('constructor', 'Initialized'); 
    }

    findTargetZone(activeZones, point, monitorIndex) { 
        // Get monitor geometry instead of work area
        const monitor = Main.layoutManager.monitors[monitorIndex];
        if (!monitor) {
            log('findTargetZone', `Invalid monitor index ${monitorIndex}`);
            return null;
        }
        
        log('findTargetZone', `Searching on monitor ${monitorIndex} (Geometry: X:${monitor.x} Y:${monitor.y} W:${monitor.width} H:${monitor.height}) for point X:${point.x} Y:${point.y}`); 
        log('findTargetZone', `Available zones for this search: ${JSON.stringify(activeZones.filter(z => z.monitorIndex === monitorIndex))}`); 
        
        for (const zone of activeZones) { 
            if (zone.monitorIndex === monitorIndex) { 
                const absoluteZoneRect = { 
                    x: monitor.x + zone.x, 
                    y: monitor.y + zone.y, 
                    width: zone.width, 
                    height: zone.height 
                };
                log('findTargetZone', `Checking zone "${zone.name || 'Unnamed'}": AbsRect: X:${absoluteZoneRect.x} Y:${absoluteZoneRect.y} W:${absoluteZoneRect.width} H:${absoluteZoneRect.height}`); 
                if (isPointInsideRect(point, absoluteZoneRect)) { 
                    log('findTargetZone', `Point IS INSIDE zone "${zone.name || 'Unnamed'}"`); 
                    return zone; 
                }
            }
        }
        log('findTargetZone', `No target zone found for point X:${point.x} Y:${point.y} on monitor ${monitorIndex}`); 
        return null; 
    }
}



===== FILE: ./modules/TabBar.js =====
// ./modules/TabBar.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Clutter from 'gi://Clutter';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';
import Pango from 'gi://Pango';
import Gio from 'gi://Gio';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import { TabDragger } from './TabDragger.js';
import {WindowManager} from "./WindowManager.js";

const TAB_INTERNAL_NON_LABEL_WIDTH = 50;
export class TabBar extends St.BoxLayout {
    static { GObject.registerClass(this);
    }

    constructor(zoneId, zoneDef, onTabClicked, settingsMgr, windowManager) {
        super({
            style_class: 'zone-tab-bar',
            vertical: false,
            x_expand: true,
            reactive: true,
        });
        this.show_on_add = false;
        this._zoneId = zoneId;
        this._zoneDef = zoneDef;
        this._onTabClicked = onTabClicked;
        this._settingsMgr = settingsMgr;
        this._windowManager = windowManager;
        this._tabsData = [];
        this.visible = false;
        this._windowTracker = Shell.WindowTracker.get_default();
        this._tabDragger = new TabDragger(this, this._onTabClicked);
        this._needsLayoutUpdate = true;
        this._destroyed = false;
        this._splitButton = null;
        this._splitButtonIcon = null;


        this.connect('style-changed', () => {
            if (this._destroyed) return;
            this._needsLayoutUpdate = true;
            this.queue_relayout();
        });
        this._addSplitButton();
    }

    vfunc_allocate(box) {
        super.vfunc_allocate(box);
        if (this._destroyed) return;
        if (this._needsLayoutUpdate || (this.visible && this.get_n_children() > 0)) {
            this._updateTabLayout(box);
            this._needsLayoutUpdate = false;
        }
    }

    requestLayoutUpdate(needsUpdate = true) {
        if (this._destroyed) return;
        this._needsLayoutUpdate = needsUpdate;
        if (needsUpdate) {
            this.queue_relayout();
        }
    }

    _updateSplitButtonIcon() {
        if (!this._splitButtonIcon || !this._settingsMgr || !this._zoneDef) return;
        const extPath = this._settingsMgr.getExtensionPath();
        if (!extPath) {
            console.error("[TabbedTilingPrefs.TabBar] Extension path not available for custom icons.");
            this._splitButtonIcon.set_icon_name(this._zoneDef.isSplitParent ? 'view-unite-symbolic' : 'view-split-horizontal-symbolic');
            return;
        }

        let iconFileName;
        if (this._zoneDef.isSplitParent) { // Zone is currently split, button action is to merge/unsplit
            iconFileName = 'full.png';
        } else { // Zone is not split, button action is to split
            iconFileName = 'split.png';
        }

        try {
            const iconFile = Gio.File.new_for_path(GLib.build_filenamev([extPath, 'images', iconFileName]));
            if (iconFile.query_exists(null)) {
                this._splitButtonIcon.set_gicon(new Gio.FileIcon({ file: iconFile }));
            } else {
                console.warn(`[TabbedTilingPrefs.TabBar] Custom icon not found: ${iconFileName}. Falling back to symbolic icon.`);
                this._splitButtonIcon.set_icon_name(this._zoneDef.isSplitParent ? 'view-unite-symbolic' : 'view-split-horizontal-symbolic');
            }
        } catch (e) {
            console.error(`[TabbedTilingPrefs.TabBar] Error loading custom icon ${iconFileName}: ${e}. Falling back.`);
            this._splitButtonIcon.set_icon_name(this._zoneDef.isSplitParent ? 'view-unite-symbolic' : 'view-split-horizontal-symbolic');
        }
    }

    _addSplitButton() {
        if (this._destroyed || this._zoneDef.isSplitChild) {
            return;
        }

        this._splitButton = new St.Button({
            style_class: 'zone-tab-bar-split-button',
            can_focus: true,
            reactive: true,
        });
        this._splitButtonIcon = new St.Icon({
            style_class: 'system-status-icon', // Keeps some consistency, or use a custom class
        });
        this._updateSplitButtonIcon(); // Set initial icon using custom PNGs
        this._splitButton.set_child(this._splitButtonIcon);
        this._splitButton.connect('clicked', () => {
            if (this._windowManager && typeof this._windowManager.toggleZoneSplit === 'function') {
                this._windowManager.toggleZoneSplit(this._zoneId);
            }
        });
        this.add_child(this._splitButton);
    }

    getTabActors() {
        if (this._destroyed) return [];
        return this._tabsData.map(td => td.actor);
    }

    hasWindow(win) {
        if (this._destroyed) return false;
        return this._tabsData.some(td => td.window === win);
    }

    _updateTabLayout(currentAllocationBox) {
        if (this._destroyed || !this.visible) return;
        const themeNode = this.get_theme_node();
        const allocation = currentAllocationBox || this.get_allocation_box();
        if (!allocation || allocation.get_width() === 0 || !themeNode) return;
        const flowChildren = this.get_children().filter(c =>
            c !== this._splitButton && // Exclude split button from this flow
            (c.visible || c.style_class === 'zone-tab-drag-slot')
        );
        const numFlowChildren = flowChildren.length;

        if (numFlowChildren === 0 && (!this._splitButton || !this._splitButton.visible)) {
            return;
        }

        const tabMinWidth = this._settingsMgr.getTabMinWidth();
        const tabMaxWidth = this._settingsMgr.getTabMaxWidth();
        const gapSpacing = this._settingsMgr.getTabSpacing();
        // Fetches the configured gap size
        const tabCornerRadius = this._settingsMgr.getTabCornerRadius();
        let availableWidth = allocation.get_width() - themeNode.get_horizontal_padding();
        let splitButtonReservation = 0;
        if (this._splitButton && this._splitButton.visible) {
            splitButtonReservation = this._splitButton.get_preferred_width(-1)[1];
            if (numFlowChildren > 0) { // If there are tabs, also reserve space for one gap before the button
                splitButtonReservation += gapSpacing;
            }
        }
        availableWidth -= splitButtonReservation;
        let totalMarginWidth = 0;
        if (numFlowChildren > 1) {
            totalMarginWidth = (numFlowChildren - 1) * gapSpacing;
        }

        // This is the width purely for the content of the flowChildren themselves
        let netWidthForFlowChildrenContent = availableWidth - totalMarginWidth;
        if (netWidthForFlowChildrenContent <= 0 && numFlowChildren > 0) {
            // Fallback if calculated space is too small (e.g. due to large gaps and many tabs)
            netWidthForFlowChildrenContent = numFlowChildren * tabMinWidth;
        }

        let childBaseWidth = tabMinWidth;
        if (numFlowChildren > 0) {
            childBaseWidth = Math.floor(netWidthForFlowChildrenContent / numFlowChildren);
        }
        // Ensure base width is within defined min/max
        childBaseWidth = Math.max(tabMinWidth, Math.min(childBaseWidth, tabMaxWidth));
        let remainderWidth = 0;
        if (numFlowChildren > 0) {
            remainderWidth = netWidthForFlowChildrenContent - (childBaseWidth * numFlowChildren);
            if (remainderWidth < 0) remainderWidth = 0;
        }

        for (let i = 0; i < flowChildren.length; i++) {
            const child = flowChildren[i];
            let currentChildActualWidth = childBaseWidth;

            if (remainderWidth > 0) { // Distribute any remaining width
                currentChildActualWidth++;
                remainderWidth--;
            }
            // Final check on width (should already be constrained but good for safety)
            currentChildActualWidth = Math.max(tabMinWidth, Math.min(currentChildActualWidth, tabMaxWidth));
            child.set_width(currentChildActualWidth);

            let dynamicStyle = `border-radius: ${tabCornerRadius}px ${tabCornerRadius}px 0 0;`;
            if (i > 0) { // Add margin-left for children after the first to create spacing
                dynamicStyle += ` margin-left: ${gapSpacing}px;`;
            }
            child.set_style(dynamicStyle);
            // St.BoxLayout will use the margin-left and its own packing logic.
            child.set_y(Math.floor((allocation.get_height() - child.get_height()) / 2));
            const tabData = this._tabsData.find(td => td.actor === child);
            if (tabData && tabData.labelActor) {
                const labelMax = currentChildActualWidth - TAB_INTERNAL_NON_LABEL_WIDTH;
                tabData.labelActor.set_style(`max-width: ${Math.max(0, labelMax)}px`);
            }
        }

        // Position the split button manually from the right, as it's not part of the flow
        if (this._splitButton && this._splitButton.visible) {
            const buttonNaturalWidth = this._splitButton.get_preferred_width(-1)[1];
            this._splitButton.set_width(buttonNaturalWidth);
            // Position from the right edge of the TabBar's allocation
            const buttonX = allocation.get_width() - themeNode.get_padding(St.Side.RIGHT) - buttonNaturalWidth;
            this._splitButton.set_x(buttonX); // Manual X position
            this._splitButton.set_y(Math.floor((allocation.get_height() - this._splitButton.get_height()) / 2));
        }
    }

    addWindow(win) {

        if (this._destroyed || this._tabsData.some(td => td.window === win)) {
            if (!this._destroyed) this.highlightWindow(win);
            return;
        }

        const app = this._windowTracker.get_window_app(win);
        const { actor, labelActor } = this._buildTabActor(win, app);
        actor.hide();

        GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {
            if (this._destroyed) {
                actor.destroy();
                return GLib.SOURCE_REMOVE;
            }

            const compositorPrivate =
               
              win.get_compositor_private?.();
            if (!compositorPrivate) {
                actor.destroy();
                return GLib.SOURCE_REMOVE;
            }

            if (this._splitButton && this._splitButton.get_parent() === this) {
               this.insert_child_below(actor, this._splitButton);
     
            } else {
                this.add_child(actor);
            }

            const unmanageId = win.connect('unmanaging', () => this.removeWindow(win));
            this._tabsData.push({ window: win, actor, labelActor, unmanageId });

            this._tabDragger.initPointerHandlers(actor, win);

            this._needsLayoutUpdate = true;
            this.queue_relayout();

            GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {
                if (this._destroyed || actor.get_parent() !== this) {
                    return GLib.SOURCE_REMOVE;
                }

                actor.show();
                this.highlightWindow(win);
     
                this._onTabClicked(win);

                if (actor.can_focus && actor.get_stage() && actor.get_paint_visibility()) {
                     actor.grab_key_focus();
                }
                return GLib.SOURCE_REMOVE;
            });
            return GLib.SOURCE_REMOVE;
        });
    }

    _onTabCloseRequested(window) {
        if (this._destroyed) return;
        window.delete(global.get_current_time());
    }

    removeWindow(win) {
        if (this._destroyed) return;
        const idx = this._tabsData.findIndex(td => td.window === win);
        if (idx < 0) return;

        const tabData = this._tabsData[idx];
        if (this._tabDragger.isDragging() && this._tabDragger.getDraggedActor() === tabData.actor) {
            this._tabDragger.cancelDrag(true);
        }

        if (tabData.unmanageId && tabData.window) {
            const compositorPrivate = tabData.window.get_compositor_private?.();
            if (compositorPrivate) {
                try {
                    tabData.window.disconnect(tabData.unmanageId);
                } catch (e) {
                }
            }
        }
        tabData.unmanageId = 0;
        if (tabData.actor._pressTimeoutId) {
            GLib.Source.remove(tabData.actor._pressTimeoutId);
            tabData.actor._pressTimeoutId = 0;
        }
        tabData.actor._pressEventDetails = null;
        if (tabData.actor.get_parent() === this) {
            this.remove_child(tabData.actor);
        }
        tabData.actor.destroy();
        this._tabsData.splice(idx, 1);
        this._needsLayoutUpdate = true;
        this.queue_relayout();
    }

    highlightWindow(win) {
        if (this._destroyed) return;
        this._tabsData.forEach(({ window: w, actor }) => {
            if (w === win) {
                actor.add_style_pseudo_class('active');
            } else {
                actor.remove_style_pseudo_class('active');
            }
        });
    }

    _buildTabActor(win, app) {
        const actor = new St.Button({
            style_class: 'zone-tab',
            reactive: true,
            can_focus: true,
        });
        const box = new St.BoxLayout({
            vertical: false,
            style_class: 'zone-tab-content',
            x_expand: true
        });
        actor.set_child(box);

        if (app?.get_icon()) {
            box.add_child(new St.Icon({
                gicon: app.get_icon(),
                icon_size: this._settingsMgr.getTabIconSize(),
                style_class: 'zone-tab-app-icon'
            }));
        }
        const fs = this._settingsMgr.getTabFontSize();
        const title = this._makeLabelText(win, app);
        // Uses the modified _makeLabelText
        const labelActor = new St.Label({
            text: title,
            y_align: Clutter.ActorAlign.CENTER
        });
        labelActor.clutter_text.set_ellipsize(Pango.EllipsizeMode.END);
        labelActor.set_style(`font-size:${fs}px;`);
        labelActor.x_expand = true;
        box.add_child(labelActor);

        const closeButton = new St.Button({
            style_class: 'zone-tab-close-button',
            can_focus: true,
            reactive: true,
        });
        closeButton.set_child(new St.Icon({
            icon_name: 'window-close-symbolic',
            icon_size: this._settingsMgr.getTabCloseButtonIconSize(),
        }));
        closeButton.connect('clicked', () => {
            this._onTabCloseRequested(win);
            return Clutter.EVENT_STOP;
        });
        box.add_child(closeButton);

        actor._tabWindow = win;
        actor._pressTimeoutId = 0;

        return { actor, labelActor };
    }

    _makeLabelText(win, app) {
        const appNameExceptions = this._settingsMgr.getAppNameExceptions();
        const wordCount = this._settingsMgr.getWindowTitleWordCount();
        let appName = app ? app.get_name() : null;
        let useWindowTitle = false;
        if (app) {
            let appID = app.get_id();
            // Check both the original case and lowercase for compatibility
            if (appID && (appNameExceptions.includes(appID) || appNameExceptions.includes(appID.toLowerCase()))) {
                useWindowTitle = true;
            }
        } 
        
        if (useWindowTitle) {
            const windowTitle = win.get_title();
            if (!windowTitle) {
                // Fallback if no window title
                return appName ||
                win.get_wm_class() || 'Untitled';
            }
            
            if (wordCount === 0) {
                // Show full window title
                return windowTitle;
            } else {
                // Show specified number of words
                const words = windowTitle.split(' ');
                if (words.length > wordCount) {
                    return words.slice(0, wordCount).join(' ');
                } else {
                    return windowTitle;
                }
            }
        }

        // Original logic if not in exceptions or no app/wmClass
        if (appName) return appName;
        const c = win.get_wm_class();
        return c ? c.replace(/[-_.]+/g, ' ').replace(/\b\w/g, m => m.toUpperCase()) : win.get_title() || 'Untitled';
    }


    destroy() {
        if (this._destroyed) return;
        this._destroyed = true;
        if (this._splitButton) {
            this._splitButton.destroy();
            this._splitButton = null;
            this._splitButtonIcon = null;
        }
        this._tabDragger.destroy();
        this._tabsData.forEach(({ unmanageId, window, actor }) => {
            if (unmanageId && window) {
                const compositorPrivate = window.get_compositor_private?.();
                if (compositorPrivate) {
                    try { window.disconnect(unmanageId); } catch (e) { /* log error */ }
          
                }
            }
            if (actor._pressTimeoutId) {
                GLib.Source.remove(actor._pressTimeoutId);
            }
        });
        this._tabsData = [];

        super.destroy();
    }

    refreshTabVisuals() {
        if (this._destroyed) return;
        this._tabsData.forEach(tabData => {
            const { actor, window } = tabData;
            const labelActor = tabData.labelActor;
            const app = this._windowTracker.get_window_app(window);

            const box = actor.get_child();
            if (!box) return;

            let appIconActor = null;
      
            let closeButtonActor = null;

            box.get_children().forEach(child => {
                if (child instanceof St.Icon && child.style_class === 'zone-tab-app-icon') {
                    appIconActor = child;
                }
               
                else if (child instanceof St.Button && child.style_class === 'zone-tab-close-button') {
                    closeButtonActor = child;
                }
            });

            if (appIconActor) box.remove_child(appIconActor);
            if (app?.get_icon()) {
            
                const newAppIcon = new St.Icon({
                    gicon: app.get_icon(),
                    icon_size: this._settingsMgr.getTabIconSize(),
                    style_class: 'zone-tab-app-icon'
                });
                if (labelActor) {
                    box.insert_child_below(newAppIcon, labelActor);
                } else {
                    box.add_child(newAppIcon);
                }
            }

            if (labelActor) {
                const fs = this._settingsMgr.getTabFontSize();
                // Update label text in case window title or app name changed or exceptions apply differently
                labelActor.set_text(this._makeLabelText(window, app));
                labelActor.set_style(`font-size:${fs}px;`);
            }

            if (closeButtonActor) {
                const oldIcon = closeButtonActor.get_child();
                if (oldIcon) oldIcon.destroy();
                closeButtonActor.set_child(new St.Icon({
                    icon_name: 'window-close-symbolic',
                    icon_size: this._settingsMgr.getTabCloseButtonIconSize(),
                }));
            }
        });

        this._updateSplitButtonIcon();

        this._needsLayoutUpdate = true;
        this.queue_relayout();
    }
}



===== FILE: ./modules/SettingsManager.js =====
// modules/SettingsManager.js

import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

const ZONE_SETTINGS_KEY                     = 'zones';
const ENABLE_ZONING_KEY                     = 'enable-auto-zoning';
const RESTORE_ON_UNTILE_KEY                 = 'restore-original-size-on-untile';
const TILE_NEW_WINDOWS_KEY                  = 'tile-new-windows';
const HIGHLIGHT_ON_HOVER_KEY                = 'highlight-on-hover';
const CYCLE_ACCELERATOR_KEY                 = 'cycle-zone-windows-accelerator';
const CYCLE_BACKWARD_ACCELERATOR_KEY        = 'cycle-zone-windows-backward-accelerator';
const TAB_BAR_HEIGHT_KEY                    = 'tab-bar-height';
const TAB_FONT_SIZE_KEY                     = 'tab-font-size';
const ZONE_GAP_SIZE_KEY                     = 'zone-gap-size';
const TAB_ICON_SIZE_KEY                     = 'tab-icon-size';
const TAB_CORNER_RADIUS_KEY                 = 'tab-corner-radius';
const TAB_CLOSE_BUTTON_ICON_SIZE_KEY        = 'tab-close-button-icon-size';
const TAB_SPACING_KEY                       = 'tab-spacing';
const TAB_MIN_WIDTH_KEY                     = 'tab-min-width';
const TAB_MAX_WIDTH_KEY                     = 'tab-max-width';
const SNAP_EVASION_KEY                      = 'snap-evasion-key';
const APP_NAME_EXCEPTIONS_KEY               = 'app-name-exceptions';
const WINDOW_TITLE_WORD_COUNT_KEY           = 'window-title-word-count';
const DEFAULT_ZONES_FILENAME                = 'default_zones.json';
const APP_NAME_EXCEPTIONS_FILENAME          = 'app_name_exceptions.json'; // Still used for backward compatibility

const log = (msg) => console.log(`[TabbedTiling.SettingsManager] ${msg}`); 

export class SettingsManager {
    constructor(gsettings, extensionPath) {
        this._gsettings       = gsettings;
        this._extensionPath   = extensionPath;
        this._zones           = [];
        this._signalHandlers  = new Map();
        
        this._loadDefaultZonesFromFileIfNeeded(); 
        this._loadZonesFromGSettings();
        this._migrateAppNameExceptionsFromFile(); // Migrate from old JSON file if needed
        
        this._connectSettingChange(ZONE_SETTINGS_KEY, () => this._loadZonesFromGSettings());
        this._connectSettingChange(ENABLE_ZONING_KEY, () => log('Enable auto zoning changed'));
        this._connectSettingChange(RESTORE_ON_UNTILE_KEY, () => log('Restore on untile changed'));
        this._connectSettingChange(TILE_NEW_WINDOWS_KEY, () => log('Tile new windows changed'));
        this._connectSettingChange(HIGHLIGHT_ON_HOVER_KEY, () => log('Highlight on hover changed'));
        this._connectSettingChange(CYCLE_ACCELERATOR_KEY, () => log('Cycle accelerator changed'));
        this._connectSettingChange(CYCLE_BACKWARD_ACCELERATOR_KEY, () => log('Backward cycle accelerator changed'));
        this._connectSettingChange(TAB_BAR_HEIGHT_KEY, () => log('Tab bar height changed'));
        this._connectSettingChange(TAB_FONT_SIZE_KEY, () => log('Tab font size changed'));
        this._connectSettingChange(ZONE_GAP_SIZE_KEY, () => log('Zone gap size changed'));
        this._connectSettingChange(TAB_ICON_SIZE_KEY, () => log('Tab icon size changed'));
        this._connectSettingChange(TAB_CORNER_RADIUS_KEY, () => log('Tab corner radius changed'));
        this._connectSettingChange(TAB_CLOSE_BUTTON_ICON_SIZE_KEY, () => log('Tab close button icon size changed'));
        this._connectSettingChange(TAB_SPACING_KEY, () => log('Tab spacing changed'));
        this._connectSettingChange(TAB_MIN_WIDTH_KEY, () => log('Tab min width changed'));
        this._connectSettingChange(TAB_MAX_WIDTH_KEY, () => log('Tab max width changed'));
        this._connectSettingChange(SNAP_EVASION_KEY, () => log(`Snap evasion key changed to: ${this.getSnapEvasionKeyName()}`));
        this._connectSettingChange(APP_NAME_EXCEPTIONS_KEY, () => log('App name exceptions changed'));
        this._connectSettingChange(WINDOW_TITLE_WORD_COUNT_KEY, () => log('Window title word count changed'));
    }

    _loadDefaultZonesFromFileIfNeeded() {
        log(`Attempting to load zones from ${DEFAULT_ZONES_FILENAME}…`);
        
        const file = Gio.File.new_for_path(GLib.build_filenamev([this._extensionPath, DEFAULT_ZONES_FILENAME]));
        
        try { 
            if (file.query_exists(null)) { 
                const [ok, contents] = file.load_contents(null);
                
                if (ok) { 
                    const json = new TextDecoder().decode(contents).trim();
                    
                    if (json.startsWith('[') && json.endsWith(']')) { 
                        const current = this._gsettings.get_string(ZONE_SETTINGS_KEY);
                        
                        if (current !== json) { 
                            this._gsettings.set_string(ZONE_SETTINGS_KEY, json);
                            log(`Default zones imported from file.`);
                        }
                    } else { 
                        log(`Default file does not contain a JSON array.`);
                    }
                } else { 
                    log(`Could not read ${DEFAULT_ZONES_FILENAME}.`);
                }
            }
        } catch (e) { 
            log(`Error loading default zones: ${e}`);
        }
    }

    _loadZonesFromGSettings() {
        try { 
            const str = this._gsettings.get_string(ZONE_SETTINGS_KEY);
            const arr = JSON.parse(str);
            this._zones = Array.isArray(arr) ? arr : [];
            log(`Loaded ${this._zones.length} zones.`);
        } catch (e) { 
            log(`Failed to parse zones JSON: ${e}`);
            this._zones = [];
        }
    }

    // Migrate app name exceptions from old JSON file to new GSettings (one-time migration)
    _migrateAppNameExceptionsFromFile() {
        const file = Gio.File.new_for_path(GLib.build_filenamev([this._extensionPath, APP_NAME_EXCEPTIONS_FILENAME]));
        try {
            if (file.query_exists(null)) {
                const [ok, contents] = file.load_contents(null);
                if (ok) {
                    const json = new TextDecoder().decode(contents).trim();
                    const arr = JSON.parse(json);
                    if (Array.isArray(arr) && arr.length > 0) {
                        // Only migrate if GSettings doesn't have any exceptions yet
                        const currentExceptions = this._gsettings.get_strv(APP_NAME_EXCEPTIONS_KEY);
                        if (currentExceptions.length === 0 || (currentExceptions.length === 1 && currentExceptions[0] === 'virt-manager.desktop')) {
                            this._gsettings.set_strv(APP_NAME_EXCEPTIONS_KEY, arr);
                            log(`Migrated ${arr.length} app name exceptions from JSON file to GSettings.`);
                            // Optionally remove the old file after successful migration
                            // file.delete(null);
                        }
                    }
                }
            }
        } catch (e) {
            log(`Error migrating app name exceptions: ${e}`);
        }
    }

    _connectSettingChange(key, callback) {
        const id = this._gsettings.connect(`changed::${key}`, callback);
        
        if (!this._signalHandlers.has(this._gsettings)) 
            this._signalHandlers.set(this._gsettings, []);
        
        this._signalHandlers.get(this._gsettings).push(id); 
    }

    getGSettingObject() {
        return this._gsettings;
    }

    getExtensionPath() { 
        return this._extensionPath;
    }

    getZones() {
        return this._zones;
    }

    // Get app name exceptions from GSettings
    getAppNameExceptions() {
        return this._gsettings.get_strv(APP_NAME_EXCEPTIONS_KEY);
    }

    // Get window title word count
    getWindowTitleWordCount() {
        return this._gsettings.get_int(WINDOW_TITLE_WORD_COUNT_KEY);
    }

    isZoningEnabled() {
        return this._gsettings.get_boolean(ENABLE_ZONING_KEY);
    }

    isRestoreOnUntileEnabled() {
        return this._gsettings.get_boolean(RESTORE_ON_UNTILE_KEY);
    }

    isTileNewWindowsEnabled() {
        return this._gsettings.get_boolean(TILE_NEW_WINDOWS_KEY);
    }

    isHighlightOnHoverEnabled() {
        return this._gsettings.get_boolean(HIGHLIGHT_ON_HOVER_KEY);
    }

    get cycleZoneWindowsAccelerator() {
        const arr = this._gsettings.get_strv(CYCLE_ACCELERATOR_KEY);
        return arr.length > 0 ? arr[0] : '';
    }

    get cycleZoneWindowsBackwardAccelerator() {
        const arr = this._gsettings.get_strv(CYCLE_BACKWARD_ACCELERATOR_KEY);
        return arr.length > 0 ? arr[0] : '';
    }

    getTabBarHeight() {
        return this._gsettings.get_int(TAB_BAR_HEIGHT_KEY);
    }

    getTabFontSize() {
        return this._gsettings.get_int(TAB_FONT_SIZE_KEY);
    }

    getZoneGapSize() {
        return this._gsettings.get_int(ZONE_GAP_SIZE_KEY);
    }

    getTabIconSize() {
        return this._gsettings.get_int(TAB_ICON_SIZE_KEY);
    }

    getTabCornerRadius() {
        return this._gsettings.get_int(TAB_CORNER_RADIUS_KEY);
    }

    getTabCloseButtonIconSize() {
        return this._gsettings.get_int(TAB_CLOSE_BUTTON_ICON_SIZE_KEY);
    }

    getTabSpacing() {
        return this._gsettings.get_int(TAB_SPACING_KEY);
    }

    getTabMinWidth() {
        return this._gsettings.get_int(TAB_MIN_WIDTH_KEY);
    }

    getTabMaxWidth() {
        return this._gsettings.get_int(TAB_MAX_WIDTH_KEY);
    }

    getSnapEvasionKeyName() {
        return this._gsettings.get_string(SNAP_EVASION_KEY);
    }

    destroy() {
        for (const [gobj, ids] of this._signalHandlers) { 
            ids.forEach(id => { 
                try { gobj.disconnect(id); } catch {} 
            });
        }
        this._signalHandlers.clear(); 
        log('Destroyed.');
    }
}



===== FILE: ./modules/ZoneHighlighter.js =====
import St from 'gi://St';
import GObject from 'gi://GObject';
import Clutter from 'gi://Clutter';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

const log = (msg) => console.log(`[TabbedTilingPrefs.ZoneHighlighter] ${msg}`);

export class ZoneHighlighter extends St.Bin {
    static {
        GObject.registerClass(this);
    }

    constructor() {
        super({
            style_class: 'zone-highlight',
            visible: false,
            reactive: false,
            x_expand: false,
            y_expand: false,
            opacity: 0,
        });
        Main.uiGroup.add_child(this);
        // Ensure it's above most other things but below popups/menus if possible
        // This might need adjustment based on other UI elements.
        // Setting a high child index:
        if (Main.uiGroup.get_children().length > 1) {
             Main.uiGroup.set_child_above_sibling(this, Main.uiGroup.get_last_child());
        }
        this._isShowing = false; // Internal state to track intent
        log("Created and added to uiGroup.");
    }

    showAt(rect) {
        this.set_position(Math.round(rect.x), Math.round(rect.y));
        this.set_size(Math.round(rect.width), Math.round(rect.height));

        this._isShowing = true;
        if (!this.visible) {
            this.set_opacity(0); // Ensure opacity is 0 before showing for fade-in
            super.show(); // Use super.show() to bypass our custom hide logic
        }

        this.remove_all_transitions(); // Clear any ongoing transitions
        this.ease({
            opacity: 255,
            duration: 100, // Short duration for responsiveness
            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
        });
    }

    hideNow() { // An immediate hide without fade
        this._isShowing = false;
        this.remove_all_transitions();
        this.set_opacity(0);
        super.hide();
    }

    requestHide() { // Fade out hide
        this._isShowing = false;
        if (this.visible) {
            this.remove_all_transitions();
            this.ease({
                opacity: 0,
                duration: 150, // Slightly longer fade-out
                mode: Clutter.AnimationMode.EASE_OUT_QUAD,
                onComplete: () => {
                    // Only hide if we still intend to be hidden (i.e., no new showAt was called)
                    if (!this._isShowing && this.opacity === 0) {
                        super.hide();
                    }
                }
            });
        }
    }

    get isShowingIntent() { // Getter for external modules to check intent
        return this._isShowing;
    }


    destroy() {
        log("Destroying...");
        this.remove_all_transitions();
        if (this.get_parent()) {
            this.get_parent().remove_child(this);
        }
        super.destroy();
    }
}



===== FILE: ./modules/HighlightManager.js =====
// modules/HighlightManager.js

import GLib from 'gi://GLib';
import Mtk from 'gi://Mtk';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import { ZoneHighlighter } from './ZoneHighlighter.js';
import { ZoneDetector } from './ZoneDetector.js';
import Clutter from 'gi://Clutter';

const HIGHLIGHT_TIMER_INTERVAL = 30;
const log = (msg) => console.log(`[TabbedTilingPrefs.HighlightManager] ${msg}`);

export class HighlightManager {
    constructor(settingsManager) {
        this._settingsManager = settingsManager;
        this._zoneDetector = new ZoneDetector();
        this._zoneHighlighters = new Map();
        this._highlightTimerId = 0;
        this._currentlyHighlightedInfo = null;

        this._initZoneHighlighters();
        log("Initialized.");
    }

    _getEvasionKeyMask() {
        const keyName = this._settingsManager.getSnapEvasionKeyName();
        switch (keyName?.toLowerCase()) {
            case 'control':
                return Clutter.ModifierType.CONTROL_MASK;
            case 'alt':
                return Clutter.ModifierType.MOD1_MASK;
            case 'shift':
                return Clutter.ModifierType.SHIFT_MASK;
            case 'super':
                return Clutter.ModifierType.MOD4_MASK;
            case 'disabled':
            default:
                return 0;
        }
    }

    _initZoneHighlighters() {
        this._destroyZoneHighlighters();
        Main.layoutManager.monitors.forEach((monitor, index) => {
            const highlighter = new ZoneHighlighter();
            this._zoneHighlighters.set(index, highlighter);
        });
        log(`Initialized ${this._zoneHighlighters.size} highlighters.`);
    }

    _destroyZoneHighlighters() {
        this._zoneHighlighters.forEach(highlighter => highlighter.destroy());
        this._zoneHighlighters.clear();
        log("Destroyed all highlighters.");
    }

    _getMonitorGeometry(monitorIndex) { 
        if (monitorIndex < 0 || monitorIndex >= Main.layoutManager.monitors.length) {
            return Main.layoutManager.monitors[Main.layoutManager.primaryIndex]; // Return full monitor geometry for primary
        }
        return Main.layoutManager.monitors[monitorIndex]; // Return full monitor geometry
    }

    _updateHighlightOnDrag() {
        if (this._highlightTimerId === 0) return GLib.SOURCE_REMOVE;

        const evasionKeyMask = this._getEvasionKeyMask();
        const [, , mods] = global.get_pointer();
        const isEvasionKeyHeld = evasionKeyMask !== 0 && (mods & evasionKeyMask) !== 0;

        if (isEvasionKeyHeld) {
            if (this._currentlyHighlightedInfo) {
                this._currentlyHighlightedInfo.highlighter.requestHide();
                this._currentlyHighlightedInfo = null;
            }
            return GLib.SOURCE_CONTINUE;
        }

        if (!this._settingsManager.isHighlightOnHoverEnabled()) {
            if (this._currentlyHighlightedInfo) {
                this._currentlyHighlightedInfo.highlighter.requestHide();
                this._currentlyHighlightedInfo = null;
            }
            return GLib.SOURCE_REMOVE;
        }

        const [pointerX, pointerY] = global.get_pointer();
        const pointerMonitorIndex = global.display.get_monitor_index_for_rect(new Mtk.Rectangle({ x: pointerX, y: pointerY, width: 1, height: 1 }));
        
        if (pointerMonitorIndex === -1) {
            if (this._currentlyHighlightedInfo) {
                this._currentlyHighlightedInfo.highlighter.requestHide();
                this._currentlyHighlightedInfo = null;
            }
            return GLib.SOURCE_CONTINUE;
        }

        const zones = this._settingsManager.getZones();
        const hoveredZone = this._zoneDetector.findTargetZone(zones, {x: pointerX, y: pointerY}, pointerMonitorIndex);
        const currentHighlighterOnPointerMonitor = this._zoneHighlighters.get(pointerMonitorIndex);

        if (hoveredZone) {
            if (!this._currentlyHighlightedInfo ||
                this._currentlyHighlightedInfo.monitorIndex !== pointerMonitorIndex ||
                (this._currentlyHighlightedInfo.zone.name || JSON.stringify(this._currentlyHighlightedInfo.zone)) !== (hoveredZone.name || JSON.stringify(hoveredZone))) {

                if (this._currentlyHighlightedInfo && this._currentlyHighlightedInfo.highlighter) {
                   this._currentlyHighlightedInfo.highlighter.requestHide();
                }

                if (currentHighlighterOnPointerMonitor) {
					const monitor = Main.layoutManager.monitors[pointerMonitorIndex]; // Changed from workArea
					const absoluteZoneRect = {
						x: monitor.x + hoveredZone.x, 
						y: monitor.y + hoveredZone.y,
						width: hoveredZone.width, 
						height: hoveredZone.height
					};
					currentHighlighterOnPointerMonitor.showAt(absoluteZoneRect);
					this._currentlyHighlightedInfo = {
						monitorIndex: pointerMonitorIndex,
						zone: hoveredZone,
						highlighter: currentHighlighterOnPointerMonitor
					};
				}
            }
        } else {
            if (this._currentlyHighlightedInfo) {
                if (this._currentlyHighlightedInfo.monitorIndex === pointerMonitorIndex) {
                    this._currentlyHighlightedInfo.highlighter.requestHide();
                    this._currentlyHighlightedInfo = null;
                }
                else if (this._currentlyHighlightedInfo.monitorIndex !== pointerMonitorIndex) {
                    this._currentlyHighlightedInfo.highlighter.requestHide();
                    this._currentlyHighlightedInfo = null;
                }
            }
        }
        return GLib.SOURCE_CONTINUE;
    }

    startUpdating() {
        const evasionKeyMask = this._getEvasionKeyMask();
        const [, , mods] = global.get_pointer();
        const isEvasionKeyHeld = evasionKeyMask !== 0 && (mods & evasionKeyMask) !== 0;

        if (isEvasionKeyHeld) {
            const keyName = this._settingsManager.getSnapEvasionKeyName();
            log(`${keyName} key is held; not starting highlight updates.`);
            this._hideAllActiveHighlighters();
            if (this._highlightTimerId > 0) {
                GLib.Source.remove(this._highlightTimerId);
                this._highlightTimerId = 0;
            }
            return;
        }

        if (this._settingsManager.isHighlightOnHoverEnabled()) {
            if (this._highlightTimerId > 0) GLib.Source.remove(this._highlightTimerId);
            this._highlightTimerId = GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, HIGHLIGHT_TIMER_INTERVAL, this._updateHighlightOnDrag.bind(this));
            log("Started highlight updates.");
        } else {
            log("Highlighting disabled, not starting updates.");
            if (this._highlightTimerId > 0) {
                GLib.Source.remove(this._highlightTimerId);
                this._highlightTimerId = 0;
            }
             this._hideAllActiveHighlighters();
        }
    }

    stopUpdating() {
        if (this._highlightTimerId > 0) {
            GLib.Source.remove(this._highlightTimerId);
            this._highlightTimerId = 0;
        }
        this._hideAllActiveHighlighters();
        this._currentlyHighlightedInfo = null;
        log("Stopped highlight updates.");
    }

    _hideAllActiveHighlighters() {
        this._zoneHighlighters.forEach(highlighter => {
            if (highlighter.isShowingIntent || highlighter.visible || highlighter.opacity > 0) {
                highlighter.requestHide();
            }
        });
    }

    reinitHighlighters() {
        this.stopUpdating();
        this._initZoneHighlighters();
    }

    destroy() {
        this.stopUpdating();
        this._destroyZoneHighlighters();
        log("Destroyed.");
    }
}



===== FILE: ./modules/Indicator.js =====
import St from 'gi://St';
import * as PanelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';
import * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';
import * as Main from 'resource:///org/gnome/shell/ui/main.js'; // MOVED TO TOP LEVEL
import { gettext as _ } from 'resource:///org/gnome/shell/extensions/extension.js';

const ENABLE_ZONING_KEY = 'enable-auto-zoning';
const log = (msg) => console.log(`[TabbedTiling.Indicator] ${msg}`);

export class Indicator {
    constructor(uuid, settingsManager, extensionObject) {
        this._uuid = uuid;
        this._settingsManager = settingsManager;
        this._extensionObject = extensionObject;
        this._indicator = null;
        this._toggleItemSignalId = 0;
        this._prefsItemSignalId = 0;

        this._init();
        log("Initialized.");
    }

    _init() {
        this._indicator = new PanelMenu.Button(0.5, _('TabbedTiling'), false);
        const icon = new St.Icon({
            icon_name: 'view-grid-symbolic',
            style_class: 'system-status-icon',
        });
        this._indicator.add_child(icon);
        this._buildMenu();
        Main.panel.addToStatusArea(this._uuid, this._indicator); // Main is imported at top
    }

    _buildMenu() {
        if (!this._indicator) return;
        this._indicator.menu.removeAll();

        const zoningEnabled = this._settingsManager.isZoningEnabled();
        const toggleItem = new PopupMenu.PopupSwitchMenuItem(
            _("Enable Auto Zoning"),
            zoningEnabled
        );

        // Ensure we don't double-connect if _buildMenu is called multiple times
        if(this._toggleItemSignalId > 0) {
            try { if (toggleItem.is_connected(this._toggleItemSignalId)) toggleItem.disconnect(this._toggleItemSignalId); }
            catch(e) { /* ignore */ }
        }
        this._toggleItemSignalId = toggleItem.connect('toggled', (item) => {
            this._settingsManager.getGSettingObject().set_boolean(ENABLE_ZONING_KEY, item.state);
        });
        this._indicator.menu.addMenuItem(toggleItem);

        this._indicator.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());

        const prefsItem = new PopupMenu.PopupMenuItem(_('Settings'));
         if(this._prefsItemSignalId > 0) {
            try { if (prefsItem.is_connected(this._prefsItemSignalId)) prefsItem.disconnect(this._prefsItemSignalId); }
            catch(e) { /* ignore */ }
        }
        this._prefsItemSignalId = prefsItem.connect('activate', () => {
            this._extensionObject.openPreferences();
        });
        this._indicator.menu.addMenuItem(prefsItem);
    }

    updateToggleState() {
        if (!this._indicator || !this._indicator.menu) return;
        const menuItems = this._indicator.menu._getMenuItems();
        if (menuItems && menuItems.length > 0 && menuItems[0] instanceof PopupMenu.PopupSwitchMenuItem) {
            // Temporarily disconnect to prevent feedback loop if setToggleState itself emits 'toggled'
            const toggleItem = menuItems[0];
            const wasConnected = this._toggleItemSignalId > 0 && toggleItem.is_connected(this._toggleItemSignalId);
            if (wasConnected) toggleItem.disconnect(this._toggleItemSignalId);
            
            toggleItem.setToggleState(this._settingsManager.isZoningEnabled());
            
            if (wasConnected) { // Reconnect if it was previously connected
                 this._toggleItemSignalId = toggleItem.connect('toggled', (item) => {
                    this._settingsManager.getGSettingObject().set_boolean(ENABLE_ZONING_KEY, item.state);
                });
            }
        }
    }

    destroy() {
        // Attempt to disconnect signals from menu items before destroying the indicator
        if (this._indicator && this._indicator.menu) {
            const menuItems = this._indicator.menu._getMenuItems();
            if (this._toggleItemSignalId > 0 && menuItems && menuItems.length > 0 && menuItems[0] instanceof PopupMenu.PopupSwitchMenuItem) {
                const toggleItem = menuItems[0];
                try { if(toggleItem.is_connected(this._toggleItemSignalId)) toggleItem.disconnect(this._toggleItemSignalId); } catch(e) {/*ignore*/}
            }
             if (this._prefsItemSignalId > 0 && menuItems && menuItems.length > 2 && menuItems[2] instanceof PopupMenu.PopupMenuItem) { // Index 2 if separator is present
                const prefsItem = menuItems[2];
                 try { if(prefsItem.is_connected(this._prefsItemSignalId)) prefsItem.disconnect(this._prefsItemSignalId); } catch(e) {/*ignore*/}
            }
        }
        this._toggleItemSignalId = 0;
        this._prefsItemSignalId = 0;

        if (this._indicator) {
            this._indicator.destroy();
            this._indicator = null;
        }
        log("Destroyed.");
    }
}



===== FILE: ./prefs.js =====
// prefs.js
import Adw from 'gi://Adw'; 
import Gdk from 'gi://Gdk'; 
import { ExtensionPreferences, gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js'; 

// Import new preference group modules
import { createGeneralSettingsGroup } from './preferences/GeneralSettingsGroup.js';
import { createTabBarSettingsGroup } from './preferences/TabBarSettingsGroup.js';
import { createTabNamingSettingsGroup } from './preferences/TabNamingSettingsGroup.js';
import { ZoneDefinitionsGroup } from './preferences/ZoneDefinitionsGroup.js';

const log = msg => console.log(`[TabbedTilingPrefs] ${msg}`); 

export default class TabbedTilingPrefs extends ExtensionPreferences {
    fillPreferencesWindow(window) {
        this._settings = this.getSettings(); 
        this._window = window; 
        this._evasionKeySignalId = 0;

        const display = Gdk.Display.get_default(); 
        const monitorCount = display?.get_monitors().get_n_items() || 1; 

        // General Settings Page
        const generalPage = new Adw.PreferencesPage({
            title: _('General'),
            icon_name: 'preferences-system-symbolic'
        }); 
        window.add(generalPage); 

        const { group: generalGroup, evasionKeySettingChangedId } = createGeneralSettingsGroup(this._settings); 
        generalPage.add(generalGroup);
        this._evasionKeySignalId = evasionKeySettingChangedId;

        // Zone Definitions Page
        const zonesPage = new Adw.PreferencesPage({
            title: _('Zones'),
            icon_name: 'applications-graphics-symbolic'
        }); 
        window.add(zonesPage);

        this._zoneDefinitionsManager = new ZoneDefinitionsGroup(this._settings, monitorCount, window);
        const zoneDefinitionsGroup = this._zoneDefinitionsManager.getWidget();
        zonesPage.add(zoneDefinitionsGroup);

        // Tab Bar Appearance Page
        const tabBarPage = new Adw.PreferencesPage({
            title: _('Tab Appearance'),
            icon_name: 'view-grid-symbolic'
        }); 
        window.add(tabBarPage);

        const tabBarGroup = createTabBarSettingsGroup(this._settings); 
        tabBarPage.add(tabBarGroup);

        // Tab Naming Page
        const tabNamingPage = new Adw.PreferencesPage({
            title: _('Tab Naming'),
            icon_name: 'format-text-symbolic'
        }); 
        window.add(tabNamingPage);

        const tabNamingGroup = createTabNamingSettingsGroup(this._settings);
        tabNamingPage.add(tabNamingGroup);

        // Disconnect the signal when the preferences window is destroyed
        if (window && typeof window.connect === 'function') { 
            window.connect('close-request', () => { 
                if (this._settings && this._evasionKeySignalId > 0) { 
                    try {
                        this._settings.disconnect(this._evasionKeySignalId); 
                        this._evasionKeySignalId = 0;
                    } catch (e) {
                        log(`Error disconnecting evasionKeySettingChangedId: ${e}`); 
                    }
                }
                return false;
            });
        }
    }
}



===== FILE: ./stylesheet.css =====
/* stylesheet.css for TabbedTiling Extension */

/* Zone Highlighter */
.zone-highlight {
    background-color: rgba(78, 154, 249, 0.2);
    border: 2px solid rgba(78, 154, 249, 0.6);
    border-radius: 6px;
}

/* Main Tab Bar Container */
.zone-tab-bar {
    background-color: rgba(0, 0, 0, 0.15);
    border-bottom: 1px solid rgba(0, 0, 0, 0.3);
    height: 32px; /* This can be seen as a fallback or default if not overridden by JS/Settings */
    transition: opacity 200ms ease-out;
    z-index: 999;
}

/* Individual Tab (St.Button) */
.zone-tab {
    background-color: rgba(50, 50, 50, 1);
    color: #ffffff;
    border-radius: 4px 4px 0 0; /* Fallback, overridden by inline style from TabBar.js for corners */
    padding: 2px 6px;
    min-height: 24px;
    border: 1px solid rgba(20,20,20,0.5);
    border-bottom-width: 0;
}

.zone-tab:hover {
    background-color: rgba(70, 70, 70, 1);
}

.zone-tab:active,
.zone-tab:focus,
.zone-tab.active {
    background-color: rgba(78, 154, 249, 1);
    color: #ffffff;
}

/* Content Box within each Tab (St.BoxLayout holding icon, label, close button) */
.zone-tab-content {
    spacing: 5px;
    /* This is a default, tab spacing is now a setting affecting margins */
}

/* App Icon within Tab */
.zone-tab-app-icon {
    /* Icon styling if needed, size is set in JS */
}

/* Close Button within Tab */
.zone-tab-close-button {
    padding: 2px;
    margin-left: 4px;
    border-radius: 12px;
    background-color: transparent;
    color: #aeaeae;
    border: none;
    box-shadow: none;
    min-width: 0;
    min-height: 0;
    transition: background-color 150ms ease-out, color 150ms ease-out;
}

.zone-tab-close-button StIcon {
    /* icon-size is set in JS */
}


.zone-tab-close-button:hover {
    background-color: rgba(255, 255, 255, 0.15);
    color: #ffffff;
}

.zone-tab-close-button:active {
    background-color: rgba(255, 255, 255, 0.25);
    color: #ffffff;
}

/* Styling for the visual slot placeholder during drag and drop */
.zone-tab-drag-slot {
    background-color: rgba(120, 120, 120, 0.2);
    border: 1px dashed rgba(200, 200, 200, 0.4);
    border-radius: 4px 4px 0 0;
    /* Should match tab corner radius ideally */
}

/* Tab Bar Split Button */
.zone-tab-bar-split-button {
    padding: 3px;
    border-radius: 4px;
    background-color: transparent;
    color: #aeaeae; /* Default icon color */
    border: none;
    box-shadow: none;
    min-width: 24px; /* Ensure it's clickable */
    min-height: 24px;
}
.zone-tab-bar-split-button:hover {
    background-color: rgba(255, 255, 255, 0.1);
    color: #ffffff;
}

.zone-tab-bar-split-button StIcon { icon-size: 24px; }



===== FILE: ./default_zones.json =====
[
  {
    "monitorIndex": 0,
    "name": "Left",
    "x": 62,
    "y": 33,
    "width": 1800,
    "height": 1407
  },
  {
    "monitorIndex": 0,
    "name": "center",
    "x": 1862,
    "y": 33,
    "width": 1800,
    "height": 1407
  },
   {
    "monitorIndex": 0,
    "name": "Right",
    "x": 3662,
    "y": 33,
    "width": 1459,
    "height": 1407
  }
]



===== FILE: ./images/full.png =====
[BINARY FILE]



===== FILE: ./images/split.png =====
[BINARY FILE]



