===== FILE: ./schemas/gschemas.compiled =====
[BINARY FILE]



===== FILE: ./schemas/org.gnome.shell.extensions.tilingshell.gschema.xml =====
<?xml version="1.0" encoding="UTF-8"?>
<schemalist gettext-domain="gnome-shell-extensions">
  <schema path="/org/gnome/shell/extensions/tilingshell/" id="org.gnome.shell.extensions.tilingshell">
    <key name="enable-auto-zoning" type="b">
      <default>true</default>
      <summary>Enable Auto Zoning</summary>
      <description>Automatically tile windows when moved into a defined zone.</description>
    </key>

    <key name="zones" type="s">
      <default>'[]'</default>
      <summary>Zone Definitions</summary>
      <description>A JSON string representing an array of zone objects. Each object: {monitorIndex: number, name: string, x: number, y: number, width: number, height: number}</description>
    </key>

    <key name="restore-original-size-on-untile" type="b">
      <default>true</default>
      <summary>Restore Original Size</summary>
      <description>When a window is moved out of a zone, restore its original size and position.</description>
    </key>

    <key name="tile-new-windows" type="b">
      <default>true</default>
      <summary>Tile New Windows</summary>
      <description>Automatically tile newly opened windows if they fall into a zone.</description>
    </key>

    <key name="highlight-on-hover" type="b">
      <default>true</default>
      <summary>Highlight Zone on Hover</summary>
      <description>Visually highlight a zone when dragging a window over it.</description>
    </key>

    <!-- NEW -->
    <key name="cycle-zone-windows-accelerator" type="s">
      <default>'<Control><Alt>Tab'</default>
      <summary>Cycle Windows in Active Zone</summary>
      <description>Keyboard shortcut to loop focus through windows snapped into the currently active zone.</description>
    </key>
  </schema>
</schemalist>


===== FILE: ./metadata.json =====
{
  "name": "Auto Zoner",
  "description": "Automatically tiles windows into predefined screen zones.",
  "uuid": "tilingshell@georgecs.com",
  "settings-schema": "org.gnome.shell.extensions.tilingshell",
  "shell-version": ["45", "46", "47", "48"],
  "version": 1,
  "gettext-domain": "auto-zoner",
  "settings-schema": "org.gnome.shell.extensions.tilingshell",
  "url": "https://github.com/your-username/auto-zoner"
}



===== FILE: ./extension.js =====
import { Extension } from 'resource:///org/gnome/shell/extensions/extension.js';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Meta from 'gi://Meta';
import Shell from 'gi://Shell';

import { SettingsManager }   from './modules/SettingsManager.js';
import { HighlightManager }  from './modules/HighlightManager.js';
import { WindowManager }     from './modules/WindowManager.js';
import { Indicator }         from './modules/Indicator.js';

const log = (msg) => console.log(`[AutoZoner.Main] ${msg}`);
const ENABLE_ZONING_KEY = 'enable-auto-zoning';

export default class AutoZonerExtension extends Extension {
    constructor(metadata) {
        super(metadata);
        this._settingsManager = null;
        this._highlightManager = null;
        this._windowManager   = null;
        this._indicator       = null;
        this._monitorsSigId   = 0;
        this._zoningSigId     = 0;
    }

    enable() {
        log('Enabling…');
        this._settingsManager = new SettingsManager(this.getSettings(), this.path);
        this._highlightManager= new HighlightManager(this._settingsManager);
        this._windowManager   = new WindowManager(this._settingsManager, this._highlightManager);
        this._indicator       = new Indicator(this.uuid, this._settingsManager, this);

        // Wire up window‐snapping signals
        this._windowManager.connectSignals();
        this._zoningSigId = this._settingsManager.connect(
            ENABLE_ZONING_KEY,
            () => {
                this._windowManager.connectSignals();
                this._indicator.updateToggleState();
            }
        );

        // Reinit highlighters on monitor change
        if (Main.layoutManager) {
            this._monitorsSigId = Main.layoutManager.connect(
                'monitors-changed',
                () => this._highlightManager.reinitHighlighters()
            );
        }

        // Register our new “cycle-zone-windows” keybinding
        Main.wm.addKeybinding(
            'cycle-zone-windows-accelerator',
            this._settingsManager.getGSettingObject(),
            Meta.KeyBindingFlags.NONE,
            Shell.ActionMode.ALL,
            () => this._windowManager.cycleWindowsInCurrentZone()
        );

        log('Enabled.');
    }

    disable() {
        log('Disabling…');

        if (this._monitorsSigId && Main.layoutManager) {
            Main.layoutManager.disconnect(this._monitorsSigId);
            this._monitorsSigId = 0;
        }
        if (this._zoningSigId) {
            this._settingsManager.getGSettingObject().disconnect(this._zoningSigId);
            this._zoningSigId = 0;
        }

        Main.wm.removeKeybinding('cycle-zone-windows-accelerator');

        this._windowManager.cleanupWindowProperties();
        this._windowManager.destroy();
        this._highlightManager.destroy();
        this._indicator.destroy();
        this._settingsManager.destroy();

        log('Disabled.');
    }
}




===== FILE: ./modules/WindowManager.js =====
import Meta from 'gi://Meta';
import GLib from 'gi://GLib';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

import { ZoneDetector } from './ZoneDetector.js';

const log = (p, msg) => console.log(`[AutoZoner.WindowManager.${p}] ${msg}`);

export class WindowManager {
    constructor(settingsManager, highlightManager) {
        this._settingsManager    = settingsManager;
        this._highlightManager   = highlightManager;
        this._zoneDetector       = new ZoneDetector();
        this._signalConnections  = [];

        // NEW: tracking snapped windows per zone
        this._snappedWindows     = {};  // { zoneId: [metaWindow, …] }
        this._cycleIndexByZone   = {};  // { zoneId: currentIndex }
        this._currentZoneId      = null;

        log('constructor', 'Initialized.');
    }

    connectSignals() {
        this._disconnectSignals();

        if (!this._settingsManager.isZoningEnabled()) {
            log('connectSignals', 'Zoning disabled, skipping signals.');
            return;
        }

        this._connect(global.display, 'grab-op-begin', (d, w, o) => this._onGrabOpBegin(d, w, o));
        this._connect(global.display, 'grab-op-end',   (d, w, o) => this._onGrabOpEnd(d, w, o));
        this._connect(global.display, 'window-created',(d, w)   => this._onWindowCreated(d, w));

        log('connectSignals', 'Signals connected.');
    }

    _connect(gobj, name, cb) {
        const id = gobj.connect(name, cb);
        this._signalConnections.push({ gobj, id });
    }

    _disconnectSignals() {
        this._signalConnections.forEach(({ gobj, id }) => {
            try {
                if (gobj.is_connected && gobj.is_connected(id))
                    gobj.disconnect(id);
                else if (gobj.disconnect)
                    gobj.disconnect(id);
            } catch (e) {
                log('_disconnectSignals', `Error: ${e}`);
            }
        });
        this._signalConnections = [];
    }

    _getMonitorWorkArea(mon) {
        const lm = Main.layoutManager;
        if (mon < 0 || mon >= lm.monitors.length)
            return lm.getWorkAreaForMonitor(lm.primaryIndex);
        return lm.getWorkAreaForMonitor(mon);
    }

    _onGrabOpBegin(display, window, op) {
        if ((op & Meta.GrabOp.MOVING) === 0) return;
        if (!window || window.is_fullscreen() || window.get_window_type() !== Meta.WindowType.NORMAL) return;

        if (this._settingsManager.isRestoreOnUntileEnabled() && !window._autoZonerOriginalRect) {
            window._autoZonerOriginalRect = window.get_frame_rect();
            log('_onGrabOpBegin', `Stored original rect for "${window.get_title()}"`);
        }

        if (this._highlightManager)
            this._highlightManager.startUpdating();
    }

    _onGrabOpEnd(display, window, op) {
        if (this._highlightManager)
            this._highlightManager.stopUpdating();

        if (!this._settingsManager.isZoningEnabled()) return;
        if (!window || window.is_fullscreen() || window.get_window_type() !== Meta.WindowType.NORMAL) {
            delete window._autoZonerIsZoned;
            return;
        }

        const { x, y, width, height } = window.get_frame_rect();
        const center = { x: x + width/2, y: y + height/2 };
        const mon = window.get_monitor();
        const zones = this._settingsManager.getZones();
        const targetZone = this._zoneDetector.findTargetZone(zones, center, mon);

        if (targetZone) {
            // Unmaximize if needed
            if (window.get_maximized())
                window.unmaximize(Meta.MaximizeFlags.BOTH);

            const workArea = this._getMonitorWorkArea(mon);
            const newX = workArea.x + targetZone.x;
            const newY = workArea.y + targetZone.y;

            // Track this window in the zone
            const zoneId = targetZone.name || JSON.stringify(targetZone);
            this._snappedWindows[zoneId] = this._snappedWindows[zoneId] || [];
            if (!this._snappedWindows[zoneId].includes(window))
                this._snappedWindows[zoneId].push(window);

            this._currentZoneId          = zoneId;
            this._cycleIndexByZone[zoneId] = 0;

            window.move_resize_frame(false, newX, newY, targetZone.width, targetZone.height);
            window._autoZonerIsZoned = true;
            log('_onGrabOpEnd', `Snapped "${window.get_title()}" into zone "${zoneId}"`);
        }
        else if (window._autoZonerIsZoned) {
            // Untile / restore
            if (this._settingsManager.isRestoreOnUntileEnabled() && window._autoZonerOriginalRect) {
                const o = window._autoZonerOriginalRect;
                window.move_resize_frame(false, o.x, o.y, o.width, o.height);
                delete window._autoZonerOriginalRect;
                log('_onGrabOpEnd', `Restored "${window.get_title()}"`);
            }
            delete window._autoZonerIsZoned;
        }
    }

    // NEW: Cycle through windows in the current zone
    cycleWindowsInCurrentZone() {
        const id = this._currentZoneId;
        const list = this._snappedWindows[id] || [];
        if (list.length < 2) return;

        let idx = (this._cycleIndexByZone[id] + 1) % list.length;
        this._cycleIndexByZone[id] = idx;

        const nextWin = list[idx];
        if (nextWin && !nextWin.minimized) {
            nextWin.activate(global.get_current_time());
        }
    }

    cleanupWindowProperties() {
        global.get_window_actors().forEach(actor => {
            const w = actor.get_meta_window();
            if (w) {
                delete w._autoZonerIsZoned;
                delete w._autoZonerOriginalRect;
            }
        });
    }

    destroy() {
        this._disconnectSignals();
        log('destroy', 'Destroyed.');
    }
}




===== FILE: ./modules/ZoneDetector.js =====
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

const log = (prefix, msg) => console.log(`[AutoZoner.ZoneDetector.${prefix}] ${msg}`);

function isPointInsideRect(point, rect) {
    const check = point.x >= rect.x && point.x <= rect.x + rect.width &&
                  point.y >= rect.y && point.y <= rect.y + rect.height;
    // log('isPointInsideRect', `Point: ${JSON.stringify(point)}, Rect: ${JSON.stringify(rect)}, Result: ${check}`);
    return check;
}

function getMonitorWorkArea(monitorIndex) {
    if (monitorIndex < 0 || monitorIndex >= Main.layoutManager.monitors.length) {
        const primaryIndex = Main.layoutManager.primaryIndex;
        // log('getMonitorWorkArea', `Invalid index ${monitorIndex}, using primary ${primaryIndex}`);
        return Main.layoutManager.getWorkAreaForMonitor(primaryIndex);
    }
    // log('getMonitorWorkArea', `Using index ${monitorIndex}`);
    return Main.layoutManager.getWorkAreaForMonitor(monitorIndex);
}

export class ZoneDetector {
    constructor() {
        // log('constructor', 'Initialized');
    }

    findTargetZone(zones, point, monitorIndex) {
        const workArea = getMonitorWorkArea(monitorIndex);
        log('findTargetZone', `Searching on monitor ${monitorIndex} (WorkArea: X:${workArea.x} Y:${workArea.y} W:${workArea.width} H:${workArea.height}) for point X:${point.x} Y:${point.y}`);
        log('findTargetZone', `Available zones for this search: ${JSON.stringify(zones.filter(z => z.monitorIndex === monitorIndex))}`);

        for (const zone of zones) {
            if (zone.monitorIndex === monitorIndex) {
                const absoluteZoneRect = {
                    x: workArea.x + zone.x,
                    y: workArea.y + zone.y,
                    width: zone.width,
                    height: zone.height
                };
                log('findTargetZone', `Checking zone "${zone.name || 'Unnamed'}": AbsRect: X:${absoluteZoneRect.x} Y:${absoluteZoneRect.y} W:${absoluteZoneRect.width} H:${absoluteZoneRect.height}`);
                if (isPointInsideRect(point, absoluteZoneRect)) {
                    log('findTargetZone', `Point IS INSIDE zone "${zone.name || 'Unnamed'}"`);
                    return zone;
                } else {
                    // log('findTargetZone', `Point is NOT inside zone "${zone.name || 'Unnamed'}"`);
                }
            }
        }
        log('findTargetZone', `No target zone found for point X:${point.x} Y:${point.y} on monitor ${monitorIndex}`);
        return null;
    }
}



===== FILE: ./modules/SettingsManager.js =====
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

const ZONE_SETTINGS_KEY                  = 'zones';
const ENABLE_ZONING_KEY                  = 'enable-auto-zoning';
const RESTORE_ON_UNTILE_KEY              = 'restore-original-size-on-untile';
const TILE_NEW_WINDOWS_KEY               = 'tile-new-windows';
const HIGHLIGHT_ON_HOVER_KEY             = 'highlight-on-hover';
const CYCLE_ACCELERATOR_KEY              = 'cycle-zone-windows-accelerator';   // NEW
const DEFAULT_ZONES_FILENAME             = 'default_zones.json';

const log = (msg) => console.log(`[AutoZoner.SettingsManager] ${msg}`);

export class SettingsManager {
    constructor(gsettings, extensionPath) {
        this._gsettings     = gsettings;
        this._extensionPath = extensionPath;
        this._zones         = [];
        this._signalHandlers= new Map();

        this._loadDefaultZonesFromFileIfNeeded();
        this._loadZonesFromGSettings(); // Initial

        this._connectSettingChange(ZONE_SETTINGS_KEY,                  () => this._loadZonesFromGSettings());
        this._connectSettingChange(CYCLE_ACCELERATOR_KEY,              () => log('Cycle accelerator changed'));
    }

    // … existing private helpers …

    getGSettingObject() {
        return this._gsettings;
    }

    getZones() {
        return this._zones;
    }

    isZoningEnabled() {
        return this._gsettings.get_boolean(ENABLE_ZONING_KEY);
    }

    isRestoreOnUntileEnabled() {
        return this._gsettings.get_boolean(RESTORE_ON_UNTILE_KEY);
    }

    isTileNewWindowsEnabled() {
        return this._gsettings.get_boolean(TILE_NEW_WINDOWS_KEY);
    }

    isHighlightOnHoverEnabled() {
        return this._gsettings.get_boolean(HIGHLIGHT_ON_HOVER_KEY);
    }

    // NEW: expose the accelerator string
    get cycleZoneWindowsAccelerator() {
        return this._gsettings.get_string(CYCLE_ACCELERATOR_KEY);
    }

    connect(key, callback) {
        return this._connectSettingChange(key, callback);
    }

    destroy() {
        this._signalHandlers.forEach((ids, gobj) => {
            ids.forEach(id => {
                try {
                    if (gobj.is_connected && gobj.is_connected(id))
                        gobj.disconnect(id);
                    else if (gobj.disconnect)
                        gobj.disconnect(id);
                } catch (e) { /* ignore */ }
            });
        });
        this._signalHandlers.clear();
        log("Destroyed.");
    }
}




===== FILE: ./modules/ZoneHighlighter.js =====
import St from 'gi://St';
import GObject from 'gi://GObject';
import Clutter from 'gi://Clutter';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

const log = (msg) => console.log(`[AutoZoner.ZoneHighlighter] ${msg}`);

export class ZoneHighlighter extends St.Bin {
    static {
        GObject.registerClass(this);
    }

    constructor() {
        super({
            style_class: 'zone-highlight',
            visible: false,
            reactive: false,
            x_expand: false,
            y_expand: false,
            opacity: 0,
        });
        Main.uiGroup.add_child(this);
        // Ensure it's above most other things but below popups/menus if possible
        // This might need adjustment based on other UI elements.
        // Setting a high child index:
        if (Main.uiGroup.get_children().length > 1) {
             Main.uiGroup.set_child_above_sibling(this, Main.uiGroup.get_last_child());
        }
        this._isShowing = false; // Internal state to track intent
        log("Created and added to uiGroup.");
    }

    showAt(rect) {
        this.set_position(Math.round(rect.x), Math.round(rect.y));
        this.set_size(Math.round(rect.width), Math.round(rect.height));

        this._isShowing = true;
        if (!this.visible) {
            this.set_opacity(0); // Ensure opacity is 0 before showing for fade-in
            super.show(); // Use super.show() to bypass our custom hide logic
        }

        this.remove_all_transitions(); // Clear any ongoing transitions
        this.ease({
            opacity: 255,
            duration: 100, // Short duration for responsiveness
            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
        });
    }

    hideNow() { // An immediate hide without fade
        this._isShowing = false;
        this.remove_all_transitions();
        this.set_opacity(0);
        super.hide();
    }

    requestHide() { // Fade out hide
        this._isShowing = false;
        if (this.visible) {
            this.remove_all_transitions();
            this.ease({
                opacity: 0,
                duration: 150, // Slightly longer fade-out
                mode: Clutter.AnimationMode.EASE_OUT_QUAD,
                onComplete: () => {
                    // Only hide if we still intend to be hidden (i.e., no new showAt was called)
                    if (!this._isShowing && this.opacity === 0) {
                        super.hide();
                    }
                }
            });
        }
    }

    get isShowingIntent() { // Getter for external modules to check intent
        return this._isShowing;
    }


    destroy() {
        log("Destroying...");
        this.remove_all_transitions();
        if (this.get_parent()) {
            this.get_parent().remove_child(this);
        }
        super.destroy();
    }
}



===== FILE: ./modules/HighlightManager.js =====
import GLib from 'gi://GLib';
import Meta from 'gi://Meta';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

import { ZoneHighlighter } from './ZoneHighlighter.js';
import { ZoneDetector } from './ZoneDetector.js';

const HIGHLIGHT_TIMER_INTERVAL = 30; // Reduced interval for more responsiveness
const log = (msg) => console.log(`[AutoZoner.HighlightManager] ${msg}`);

export class HighlightManager {
    constructor(settingsManager) {
        this._settingsManager = settingsManager;
        this._zoneDetector = new ZoneDetector();
        this._zoneHighlighters = new Map();
        this._highlightTimerId = 0;
        this._currentlyHighlightedInfo = null; // { monitorIndex, zone, highlighter }

        this._initZoneHighlighters();
        log("Initialized.");
    }

    _initZoneHighlighters() {
        this._destroyZoneHighlighters();
        Main.layoutManager.monitors.forEach((monitor, index) => {
            const highlighter = new ZoneHighlighter();
            this._zoneHighlighters.set(index, highlighter);
        });
        log(`Initialized ${this._zoneHighlighters.size} highlighters.`);
    }

    _destroyZoneHighlighters() {
        this._zoneHighlighters.forEach(highlighter => highlighter.destroy());
        this._zoneHighlighters.clear();
        log("Destroyed all highlighters.");
    }

    _getMonitorWorkArea(monitorIndex) {
        if (monitorIndex < 0 || monitorIndex >= Main.layoutManager.monitors.length) {
            return Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
        }
        return Main.layoutManager.getWorkAreaForMonitor(monitorIndex);
    }

    _updateHighlightOnDrag() {
        // If timer is stopped externally (e.g., drag ends), this ensures it doesn't run.
        if (this._highlightTimerId === 0) return GLib.SOURCE_REMOVE;

        if (!this._settingsManager.isHighlightOnHoverEnabled()) {
            if (this._currentlyHighlightedInfo) {
                this._currentlyHighlightedInfo.highlighter.requestHide();
                this._currentlyHighlightedInfo = null;
            }
            return GLib.SOURCE_REMOVE; // Stop timer if highlighting is globally disabled
        }

        const [pointerX, pointerY] = global.get_pointer();
        const pointerMonitorIndex = global.display.get_monitor_index_for_rect(new Meta.Rectangle({ x: pointerX, y: pointerY, width: 1, height: 1 }));

        if (pointerMonitorIndex === -1) { // Pointer not on any monitor
            if (this._currentlyHighlightedInfo) {
                this._currentlyHighlightedInfo.highlighter.requestHide();
                this._currentlyHighlightedInfo = null;
            }
            return GLib.SOURCE_CONTINUE;
        }

        const zones = this._settingsManager.getZones();
        const hoveredZone = this._zoneDetector.findTargetZone(zones, {x: pointerX, y: pointerY}, pointerMonitorIndex);
        const currentHighlighterOnPointerMonitor = this._zoneHighlighters.get(pointerMonitorIndex);

        if (hoveredZone) {
            // Is this a new zone or a different monitor than what's currently highlighted?
            if (!this._currentlyHighlightedInfo ||
                this._currentlyHighlightedInfo.monitorIndex !== pointerMonitorIndex ||
                this._currentlyHighlightedInfo.zone.name !== hoveredZone.name || // Compare by a unique zone identifier if available
                this._currentlyHighlightedInfo.zone.x !== hoveredZone.x ||       // Or by all relevant properties
                this._currentlyHighlightedInfo.zone.y !== hoveredZone.y) {

                // Hide previous highlighter if it exists and is on a different monitor or is a different zone
                if (this._currentlyHighlightedInfo && this._currentlyHighlightedInfo.highlighter) {
                    this._currentlyHighlightedInfo.highlighter.requestHide();
                }

                if (currentHighlighterOnPointerMonitor) {
                    const workArea = this._getMonitorWorkArea(pointerMonitorIndex);
                    const absoluteZoneRect = {
                        x: workArea.x + hoveredZone.x, y: workArea.y + hoveredZone.y,
                        width: hoveredZone.width, height: hoveredZone.height
                    };
                    currentHighlighterOnPointerMonitor.showAt(absoluteZoneRect);
                    this._currentlyHighlightedInfo = {
                        monitorIndex: pointerMonitorIndex,
                        zone: hoveredZone,
                        highlighter: currentHighlighterOnPointerMonitor
                    };
                } else {
                     this._currentlyHighlightedInfo = null; // No highlighter for this monitor
                }
            }
            // If it's the same zone and monitor, do nothing, the highlighter is already shown.
        } else { // Not hovering any zone on the current monitor
            if (this._currentlyHighlightedInfo) {
                // Only hide if the current highlight was on the same monitor the pointer is now on,
                // or if the pointer moved off all monitors entirely (handled by pointerMonitorIndex === -1 case)
                if (this._currentlyHighlightedInfo.monitorIndex === pointerMonitorIndex) {
                    this._currentlyHighlightedInfo.highlighter.requestHide();
                    this._currentlyHighlightedInfo = null;
                }
            }
        }
        return GLib.SOURCE_CONTINUE;
    }

    startUpdating() {
        if (this._settingsManager.isHighlightOnHoverEnabled()) {
            if (this._highlightTimerId > 0) GLib.Source.remove(this._highlightTimerId); // Clear previous
            this._highlightTimerId = GLib.timeout_add(GLib.PRIORITY_DEFAULT_IDLE, HIGHLIGHT_TIMER_INTERVAL, this._updateHighlightOnDrag.bind(this));
            log("Started highlight updates.");
        } else {
            log("Highlighting disabled, not starting updates.");
            if (this._highlightTimerId > 0) { // Ensure timer is stopped if setting is off
                GLib.Source.remove(this._highlightTimerId);
                this._highlightTimerId = 0;
            }
             this._hideAllActiveHighlighters(); // Ensure all are hidden if setting is off
        }
    }

    stopUpdating() {
        if (this._highlightTimerId > 0) {
            GLib.Source.remove(this._highlightTimerId);
            this._highlightTimerId = 0;
        }
        this._hideAllActiveHighlighters();
        this._currentlyHighlightedInfo = null;
        log("Stopped highlight updates.");
    }

    _hideAllActiveHighlighters() { // Renamed to avoid conflict with ZoneHighlighter's own hide
        this._zoneHighlighters.forEach(highlighter => {
            if (highlighter.isShowingIntent || highlighter.visible) { // Check intent or actual visibility
                highlighter.requestHide();
            }
        });
    }

    reinitHighlighters() {
        this.stopUpdating(); // Stop current operations
        this._initZoneHighlighters();
        // No need to restart updating here, it will be started on next grab-op-begin if enabled
    }

    destroy() {
        this.stopUpdating();
        this._destroyZoneHighlighters();
        log("Destroyed.");
    }
}



===== FILE: ./modules/Indicator.js =====
import St from 'gi://St';
import * as PanelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';
import * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';
import * as Main from 'resource:///org/gnome/shell/ui/main.js'; // MOVED TO TOP LEVEL
import { gettext as _ } from 'resource:///org/gnome/shell/extensions/extension.js';

const ENABLE_ZONING_KEY = 'enable-auto-zoning';
const log = (msg) => console.log(`[AutoZoner.Indicator] ${msg}`);

export class Indicator {
    constructor(uuid, settingsManager, extensionObject) {
        this._uuid = uuid;
        this._settingsManager = settingsManager;
        this._extensionObject = extensionObject;
        this._indicator = null;
        this._toggleItemSignalId = 0;
        this._prefsItemSignalId = 0;

        this._init();
        log("Initialized.");
    }

    _init() {
        this._indicator = new PanelMenu.Button(0.5, _('Auto Zoner'), false);
        const icon = new St.Icon({
            icon_name: 'view-grid-symbolic',
            style_class: 'system-status-icon',
        });
        this._indicator.add_child(icon);
        this._buildMenu();
        Main.panel.addToStatusArea(this._uuid, this._indicator); // Main is imported at top
    }

    _buildMenu() {
        if (!this._indicator) return;
        this._indicator.menu.removeAll();

        const zoningEnabled = this._settingsManager.isZoningEnabled();
        const toggleItem = new PopupMenu.PopupSwitchMenuItem(
            _("Enable Auto Zoning"),
            zoningEnabled
        );

        // Ensure we don't double-connect if _buildMenu is called multiple times
        if(this._toggleItemSignalId > 0) {
            try { if (toggleItem.is_connected(this._toggleItemSignalId)) toggleItem.disconnect(this._toggleItemSignalId); }
            catch(e) { /* ignore */ }
        }
        this._toggleItemSignalId = toggleItem.connect('toggled', (item) => {
            this._settingsManager.getGSettingObject().set_boolean(ENABLE_ZONING_KEY, item.state);
        });
        this._indicator.menu.addMenuItem(toggleItem);

        this._indicator.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());

        const prefsItem = new PopupMenu.PopupMenuItem(_('Settings'));
         if(this._prefsItemSignalId > 0) {
            try { if (prefsItem.is_connected(this._prefsItemSignalId)) prefsItem.disconnect(this._prefsItemSignalId); }
            catch(e) { /* ignore */ }
        }
        this._prefsItemSignalId = prefsItem.connect('activate', () => {
            this._extensionObject.openPreferences();
        });
        this._indicator.menu.addMenuItem(prefsItem);
    }

    updateToggleState() {
        if (!this._indicator || !this._indicator.menu) return;
        const menuItems = this._indicator.menu._getMenuItems();
        if (menuItems && menuItems.length > 0 && menuItems[0] instanceof PopupMenu.PopupSwitchMenuItem) {
            // Temporarily disconnect to prevent feedback loop if setToggleState itself emits 'toggled'
            const toggleItem = menuItems[0];
            const wasConnected = this._toggleItemSignalId > 0 && toggleItem.is_connected(this._toggleItemSignalId);
            if (wasConnected) toggleItem.disconnect(this._toggleItemSignalId);
            
            toggleItem.setToggleState(this._settingsManager.isZoningEnabled());
            
            if (wasConnected) { // Reconnect if it was previously connected
                 this._toggleItemSignalId = toggleItem.connect('toggled', (item) => {
                    this._settingsManager.getGSettingObject().set_boolean(ENABLE_ZONING_KEY, item.state);
                });
            }
        }
    }

    destroy() {
        // Attempt to disconnect signals from menu items before destroying the indicator
        if (this._indicator && this._indicator.menu) {
            const menuItems = this._indicator.menu._getMenuItems();
            if (this._toggleItemSignalId > 0 && menuItems && menuItems.length > 0 && menuItems[0] instanceof PopupMenu.PopupSwitchMenuItem) {
                const toggleItem = menuItems[0];
                try { if(toggleItem.is_connected(this._toggleItemSignalId)) toggleItem.disconnect(this._toggleItemSignalId); } catch(e) {/*ignore*/}
            }
             if (this._prefsItemSignalId > 0 && menuItems && menuItems.length > 2 && menuItems[2] instanceof PopupMenu.PopupMenuItem) { // Index 2 if separator is present
                const prefsItem = menuItems[2];
                 try { if(prefsItem.is_connected(this._prefsItemSignalId)) prefsItem.disconnect(this._prefsItemSignalId); } catch(e) {/*ignore*/}
            }
        }
        this._toggleItemSignalId = 0;
        this._prefsItemSignalId = 0;

        if (this._indicator) {
            this._indicator.destroy();
            this._indicator = null;
        }
        log("Destroyed.");
    }
}



===== FILE: ./prefs.js =====
import Adw from 'gi://Adw';
import Gtk from 'gi://Gtk';
import Gio from 'gi://Gio';
import GObject from 'gi://GObject';
import Gdk from 'gi://Gdk';

import { ExtensionPreferences, gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';

const ZONE_SETTINGS_KEY = 'zones';
const ENABLE_ZONING_KEY = 'enable-auto-zoning';
const RESTORE_ON_UNTILE_KEY = 'restore-original-size-on-untile';
const TILE_NEW_WINDOWS_KEY = 'tile-new-windows';
const HIGHLIGHT_ON_HOVER_KEY = 'highlight-on-hover'; // NEW

const log = (msg) => console.log(`[AutoZonerPrefs] ${msg}`);

class ZoneEditorGrid extends Gtk.Grid { // (Keep this class as is from previous response)
    static {
        GObject.registerClass({ Signals: { 'changed': {} } }, this);
    }
    constructor(zoneData, monitorCount) {
        super({ column_spacing: 12, row_spacing: 6, margin_top: 10, margin_bottom: 10, margin_start: 10, margin_end: 10, hexpand: true });
        this._zone = { ...zoneData };
        this.attach(new Gtk.Label({ label: _('Name:'), halign: Gtk.Align.END, hexpand: false }), 0, 0, 1, 1);
        this._nameEntry = new Gtk.Entry({ text: this._zone.name || '', hexpand: true });
        this._nameEntry.connect('changed', () => { this._zone.name = this._nameEntry.get_text(); this.emit('changed'); });
        this.attach(this._nameEntry, 1, 0, 3, 1);
        this.attach(new Gtk.Label({ label: _('Monitor Index:'), halign: Gtk.Align.END }), 0, 1, 1, 1);
        this._monitorSpin = Gtk.SpinButton.new_with_range(0, Math.max(0, monitorCount - 1), 1);
        this._monitorSpin.set_value(this._zone.monitorIndex || 0);
        this._monitorSpin.connect('value-changed', () => { this._zone.monitorIndex = this._monitorSpin.get_value_as_int(); this.emit('changed'); });
        this.attach(this._monitorSpin, 1, 1, 1, 1);
        const fields = [ { label: _('X:'), key: 'x' }, { label: _('Y:'), key: 'y' }, { label: _('Width:'), key: 'width' }, { label: _('Height:'), key: 'height' }];
        fields.forEach((field, index) => {
            const row = Math.floor(index / 2) + 2; const col = (index % 2) * 2;
            this.attach(new Gtk.Label({ label: field.label, halign: Gtk.Align.END }), col, row, 1, 1);
            const spin = Gtk.SpinButton.new_with_range(0, 10000, 10);
            spin.set_value(this._zone[field.key] || 0); spin.set_hexpand(true);
            spin.connect('value-changed', () => { this._zone[field.key] = spin.get_value_as_int(); this.emit('changed'); });
            this.attach(spin, col + 1, row, 1, 1);
        });
    }
    get_zone_data() { return { ...this._zone }; }
}

export default class AutoZonerPrefs extends ExtensionPreferences {
    fillPreferencesWindow(window) {
        this._settings = this.getSettings();
        this._window = window;

        const display = Gdk.Display.get_default();
        const monitors = display.get_monitors();
        const monitorCount = monitors.get_n_items();

        const page = new Adw.PreferencesPage();
        window.add(page);

        // General Group
        const generalGroup = new Adw.PreferencesGroup({ title: _('General Settings') });
        page.add(generalGroup);

        let enableSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER });
        this._settings.bind(ENABLE_ZONING_KEY, enableSwitch, 'active', Gio.SettingsBindFlags.DEFAULT);
        let enableRow = new Adw.ActionRow({ title: _('Enable Auto Zoning'), subtitle: _('Globally enable or disable the extension'), activatable_widget: enableSwitch });
        enableRow.add_suffix(enableSwitch);
        generalGroup.add(enableRow);

        // NEW: Highlight on hover switch
        const highlightSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER });
        this._settings.bind(HIGHLIGHT_ON_HOVER_KEY, highlightSwitch, 'active', Gio.SettingsBindFlags.DEFAULT);
        const highlightRow = new Adw.ActionRow({
            title: _('Highlight Zone on Hover'),
            subtitle: _('Visually highlight a zone when dragging a window over it'),
            activatable_widget: highlightSwitch
        });
        highlightRow.add_suffix(highlightSwitch);
        generalGroup.add(highlightRow); // Add this to the general group


        let restoreSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER });
        this._settings.bind(RESTORE_ON_UNTILE_KEY, restoreSwitch, 'active', Gio.SettingsBindFlags.DEFAULT);
        let restoreRow = new Adw.ActionRow({ title: _('Restore Original Size on Untile'), subtitle: _('When a window is moved out of all zones, restore its previous size and position'), activatable_widget: restoreSwitch });
        restoreRow.add_suffix(restoreSwitch);
        generalGroup.add(restoreRow);

        let newWindowsSwitch = new Gtk.Switch({ valign: Gtk.Align.CENTER });
        this._settings.bind(TILE_NEW_WINDOWS_KEY, newWindowsSwitch, 'active', Gio.SettingsBindFlags.DEFAULT);
        let newWindowsRow = new Adw.ActionRow({ title: _('Tile New Windows'), subtitle: _('Automatically tile newly opened windows if their center falls into a zone'), activatable_widget: newWindowsSwitch });
        newWindowsRow.add_suffix(newWindowsSwitch);
        generalGroup.add(newWindowsRow);

        // Zones Group
        this._zonesGroup = new Adw.PreferencesGroup({ title: _('Zone Definitions'), description: _('Define areas on your screen where windows will automatically tile.') });
        page.add(this._zonesGroup);
        this._loadZonesToUI(monitorCount);
        this._addButtonRow = new Adw.ActionRow();
        const addButton = new Gtk.Button({ label: _('Add New Zone'), halign: Gtk.Align.CENTER, css_classes: ['suggested-action'] });
        addButton.connect('clicked', () => this._addZone(monitorCount));
        this._addButtonRow.set_child(addButton);
        this._zonesGroup.add(this._addButtonRow);
    }

    // (_loadZonesToUI, _createAndAddZoneExpander, _addZone, _saveZones methods remain the same as previous response)
    _loadZonesToUI(monitorCount) {
        const rowsToRemove = [];
        for (let i = 0; i < this._zonesGroup.get_n_children(); i++) {
            const child = this._zonesGroup.get_child_at_index(i);
            if (child instanceof Adw.ExpanderRow) rowsToRemove.push(child);
        }
        rowsToRemove.forEach(row => this._zonesGroup.remove(row));
        const zonesJson = this._settings.get_string(ZONE_SETTINGS_KEY);
        let zones = [];
        try { zones = JSON.parse(zonesJson); if (!Array.isArray(zones)) zones = []; }
        catch (e) { log(`Error parsing zones for UI: ${e}`); zones = []; }
        zones.forEach(zoneData => this._createAndAddZoneExpander(zoneData, monitorCount));
    }
    _createAndAddZoneExpander(zoneData, monitorCount) {
        const editorGrid = new ZoneEditorGrid(zoneData, monitorCount);
        const expanderRow = new Adw.ExpanderRow({ title: zoneData.name || _('Unnamed Zone'), subtitle: `X:${zoneData.x}, Y:${zoneData.y}, W:${zoneData.width}, H:${zoneData.height}, M:${zoneData.monitorIndex + 1}` });
        expanderRow.add_row(editorGrid);
        const removeButton = new Gtk.Button({ icon_name: 'edit-delete-symbolic', valign: Gtk.Align.CENTER, tooltip_text: _("Remove Zone"), css_classes: ['flat', 'circular'] });
        expanderRow.add_suffix(removeButton); expanderRow.set_enable_expansion(true);
        editorGrid.connect('changed', () => {
            const cd = editorGrid.get_zone_data();
            expanderRow.title = cd.name || _('Unnamed Zone');
            expanderRow.subtitle = `X:${cd.x}, Y:${cd.y}, W:${cd.width}, H:${cd.height}, M:${cd.monitorIndex + 1}`;
            this._saveZones();
        });
        removeButton.connect('clicked', () => {
            const dialog = new Adw.MessageDialog({ heading: _("Remove Zone?"), body: _("Are you sure you want to remove the zone “%s”?").format(expanderRow.title), transient_for: this._window, modal: true });
            dialog.add_response("cancel", _("Cancel")); dialog.add_response("remove", _("Remove"));
            dialog.set_response_appearance("remove", Adw.ResponseAppearance.DESTRUCTIVE);
            dialog.connect("response", (s, resp) => { if (resp === "remove") { this._zonesGroup.remove(expanderRow); this._saveZones(); } dialog.destroy(); });
            dialog.present();
        });
        if (this._addButtonRow) this._zonesGroup.add_before(expanderRow, this._addButtonRow); else this._zonesGroup.add(expanderRow);
    }
    _addZone(monitorCount) {
        let zc = 0; for (let i = 0; i < this._zonesGroup.get_n_children(); i++) if (this._zonesGroup.get_child_at_index(i) instanceof Adw.ExpanderRow) zc++;
        const nz = { monitorIndex: 0, name: _('New Zone %d').format(zc + 1), x: 0, y: 0, width: 1280, height: 720 };
        this._createAndAddZoneExpander(nz, monitorCount); this._saveZones();
    }
    _saveZones() {
        const zones = [];
        for (let i = 0; i < this._zonesGroup.get_n_children(); i++) {
            const child = this._zonesGroup.get_child_at_index(i);
            if (child instanceof Adw.ExpanderRow && child.get_n_rows() > 0) {
                const eg = child.get_row_at_index(0); if (eg instanceof ZoneEditorGrid) zones.push(eg.get_zone_data());
            }
        }
        this._settings.set_string(ZONE_SETTINGS_KEY, JSON.stringify(zones)); log(`Saved ${zones.length} zones.`);
    }
}



===== FILE: ./stylesheet.css =====
/* Add this for the highlighter */
.zone-highlight {
    background-color: rgba(78, 154, 249, 0.2); /* A semi-transparent blue */
    border: 2px solid rgba(78, 154, 249, 0.6);
    border-radius: 6px;
    /* transition: opacity 100ms ease-out, all 50ms ease-out; */ /* Optional: for smoother transitions */
}



===== FILE: ./default_zones.json =====
[
  {
    "monitorIndex": 0,
    "name": "Default Left Half (from file)",
    "x": 0,
    "y": 0,
    "width": 2560,
    "height": 1440
  },
  {
    "monitorIndex": 0,
    "name": "Default Right Half (from file)",
    "x": 2560,
    "y": 0,
    "width": 1280,
    "height": 1440
  },
   {
    "monitorIndex": 0,
    "name": "Default Right Half (from file)",
    "x": 3840,
    "y": 0,
    "width": 1280,
    "height": 1440
  }
]



